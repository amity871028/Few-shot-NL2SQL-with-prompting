
index is 288
SELECT count(*) ,  t2.name FROM hiring AS t1 JOIN shop AS t2 ON t1.shop_id  =  t2.shop_id GROUP BY t2.name
For each shop, return the number of employees working there and the name of the shop.
SQL generation:
SELECT count(T2.Employee_ID), T1.Name FROM shop AS T1 JOIN hiring AS T2 ON T1.Shop_ID  =  T2.Shop_ID GROUP BY T1.Name
self correction:
SELECT count(T2.Employee_ID), T1.Name FROM shop AS T1 JOIN hiring AS T2 ON T1.Shop_ID  =  T2.Shop_ID GROUP BY T1.Name

index is 289
SELECT sum(bonus) FROM evaluation
What is total bonus given in all evaluations?
SQL generation:
SELECT SUM(bonus) FROM evaluation
self correction:
SELECT SUM(Bonus) FROM evaluation

index is 290
SELECT sum(bonus) FROM evaluation
Find the total amount of bonus given in all the evaluations.
SQL generation:
SELECT SUM(bonus) FROM evaluation
self correction:
SELECT SUM(Bonus) FROM evaluation

index is 291
SELECT * FROM hiring
Give me all the information about hiring.
SQL generation:
SELECT * FROM hiring
self correction:
SELECT * FROM hiring

index is 292
SELECT * FROM hiring
What is all the information about hiring?
SQL generation:
SELECT * FROM hiring
self correction:
SELECT * FROM hiring

index is 293
SELECT district FROM shop WHERE Number_products  <  3000 INTERSECT SELECT district FROM shop WHERE Number_products  >  10000
Which district has both stores with less than 3000 products and stores with more than 10000 products?
SQL generation:
SELECT district FROM shop WHERE district IN (SELECT district FROM shop WHERE number_products < 3000) AND district IN (SELECT district FROM shop WHERE number_products > 10000)
self correction:
SELECT DISTINCT district FROM shop WHERE district IN (SELECT district FROM shop WHERE number_products < 3000) AND district IN (SELECT district FROM shop WHERE number_products > 10000)

index is 294
SELECT district FROM shop WHERE Number_products  <  3000 INTERSECT SELECT district FROM shop WHERE Number_products  >  10000
Find the districts in which there are both shops selling less than 3000 products and shops selling more than 10000 products.
SQL generation:
SELECT DISTINCT district FROM shop WHERE shop_id IN (SELECT shop_id FROM shop WHERE number_products < 3000) AND shop_id IN (SELECT shop_id FROM shop WHERE number_products > 10000)
self correction:
SELECT DISTINCT District FROM shop WHERE Shop_ID IN (SELECT Shop_ID FROM shop WHERE Number_products < 3000) OR Shop_ID IN (SELECT Shop_ID FROM shop WHERE Number_products > 10000)

index is 295
SELECT count(DISTINCT LOCATION) FROM shop
How many different store locations are there?
SQL generation:
SELECT COUNT(DISTINCT location) FROM shop
self correction:
SELECT COUNT(DISTINCT location) FROM shop

index is 296
SELECT count(DISTINCT LOCATION) FROM shop
Count the number of distinct store locations.
SQL generation:
SELECT COUNT(DISTINCT location) FROM shop
self correction:
SELECT COUNT(DISTINCT Location) FROM shop

index is 297
SELECT count(*) FROM Documents
How many documents do we have?
SQL generation:
SELECT COUNT(*) FROM documents
self correction:
SELECT COUNT(*) FROM Documents

index is 298
SELECT count(*) FROM Documents
Count the number of documents.
SQL generation:
SELECT COUNT(*) FROM documents
self correction:
SELECT COUNT(*) FROM Documents

index is 299
SELECT document_id ,  document_name ,  document_description FROM Documents
List document IDs, document names, and document descriptions for all documents.
SQL generation:
SELECT document_id ,  document_name ,  document_description FROM documents
self correction:
SELECT Document_ID, Document_Name, Document_Description FROM Documents

index is 300
SELECT document_id ,  document_name ,  document_description FROM Documents
What are the ids, names, and descriptions for all documents?
SQL generation:
SELECT document_id, document_name, document_description FROM documents
self correction:
SELECT Document_ID, Document_Name, Document_Description FROM Documents

index is 301
SELECT document_name ,  template_id FROM Documents WHERE Document_Description LIKE "%w%"
What is the document name and template id for document with description with the letter 'w' in it?
SQL generation:
SELECT document_name ,  template_id FROM documents WHERE document_description LIKE '%w%'
self correction:
SELECT Document_Name, Template_ID FROM Documents WHERE Document_Description LIKE '%w%'

index is 302
SELECT document_name ,  template_id FROM Documents WHERE Document_Description LIKE "%w%"
Return the names and template ids for documents that contain the letter w in their description.
SQL generation:
SELECT document_name, template_id FROM documents WHERE document_description LIKE '%w%'
self correction:
SELECT Document_Name, Template_ID  FROM Documents  WHERE Document_Description LIKE '%w%'

index is 303
SELECT document_id ,  template_id ,  Document_Description FROM Documents WHERE document_name  =  "Robbin CV"
What is the document id, template id and description for document named "Robbin CV"?
SQL generation:
SELECT document_id , template_id , document_description FROM documents WHERE document_name  =  'Robbin CV'
self correction:
SELECT Document_ID, Template_ID, Document_Description FROM Documents WHERE Document_Name  =  'Robbin CV'

index is 304
SELECT document_id ,  template_id ,  Document_Description FROM Documents WHERE document_name  =  "Robbin CV"
Return the document id, template id, and description for the document with the name Robbin CV.
SQL generation:
SELECT document_id, template_id, document_description FROM documents WHERE document_name  =  'Robbin CV'
self correction:
SELECT Document_ID, Template_ID, Document_Description FROM Documents WHERE Document_Name  =  'Robbin CV'

index is 305
SELECT count(DISTINCT template_id) FROM Documents
How many different templates do all document use?
SQL generation:
SELECT COUNT(DISTINCT template_id) FROM documents
self correction:
SELECT COUNT(DISTINCT Template_ID) FROM Documents

index is 306
SELECT count(DISTINCT template_id) FROM Documents
Count the number of different templates used for documents.
SQL generation:
SELECT COUNT(DISTINCT template_id) FROM documents
self correction:
SELECT COUNT(DISTINCT Template_ID) FROM Documents

index is 307
SELECT count(*) FROM Documents AS T1 JOIN Templates AS T2 ON T1.Template_ID  =  T2.Template_ID WHERE T2.Template_Type_Code  =  'PPT'
How many documents are using the template with type code 'PPT'?
SQL generation:
SELECT COUNT(*) FROM documents JOIN templates ON documents.Template_ID = templates.Template_ID WHERE templates.Template_Type_Code = 'PPT'
self correction:
SELECT COUNT(DISTINCT Documents.Document_ID)  FROM Documents  JOIN Templates ON Documents.Template_ID = Templates.Template_ID  WHERE Templates.Template_Type_Code = 'PPT'

index is 308
SELECT count(*) FROM Documents AS T1 JOIN Templates AS T2 ON T1.Template_ID  =  T2.Template_ID WHERE T2.Template_Type_Code  =  'PPT'
Count the number of documents that use the PPT template type.
SQL generation:
SELECT count(T1.document_id) FROM documents AS T1 JOIN templates AS T2 ON T1.template_id  =  T2.template_id WHERE T2.template_type_code  =  'PPT'
self correction:
SELECT count(Documents.Document_ID)  FROM Documents  JOIN Templates ON Documents.Template_ID = Templates.Template_ID  JOIN Ref_Template_Types ON Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code  WHERE Ref_Template_Types.Template_Type_Code = 'PPT'

index is 309
SELECT template_id ,  count(*) FROM Documents GROUP BY template_id
Show all template ids and number of documents using each template.
SQL generation:
SELECT template_id ,  COUNT(document_id) FROM documents GROUP BY template_id
self correction:
SELECT Templates.Template_ID, COUNT(Documents.Document_ID)  FROM Templates  JOIN Documents ON Templates.Template_ID = Documents.Template_ID  GROUP BY Templates.Template_ID

index is 310
SELECT template_id ,  count(*) FROM Documents GROUP BY template_id
What are all different template ids used for documents, and how many times were each of them used?
SQL generation:
SELECT template_id ,  COUNT(*) FROM documents GROUP BY template_id
self correction:
SELECT Template_ID, COUNT(*) FROM Documents GROUP BY Template_ID

index is 311
SELECT T1.template_id ,  T2.Template_Type_Code FROM Documents AS T1 JOIN Templates AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_id ORDER BY count(*) DESC LIMIT 1
What is the id and type code for the template used by the most documents?
SQL generation:
SELECT T1.template_id ,  T2.template_type_code FROM documents AS T1 JOIN templates AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_id ORDER BY COUNT(*) DESC LIMIT 1
self correction:
SELECT T1.Template_ID ,  T2.Template_Type_Code  FROM Documents AS T1  JOIN Templates AS T2 ON T1.Template_ID  =  T2.Template_ID  GROUP BY T1.Template_ID, T2.Template_Type_Code  ORDER BY COUNT(*) DESC  LIMIT 1

index is 312
SELECT T1.template_id ,  T2.Template_Type_Code FROM Documents AS T1 JOIN Templates AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_id ORDER BY count(*) DESC LIMIT 1
Return the id and type code of the template that is used for the greatest number of documents.
SQL generation:
SELECT T1.template_id ,  T1.template_type_code FROM templates AS T1 JOIN documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_id ,  T1.template_type_code ORDER BY COUNT(*) DESC LIMIT 1
self correction:
SELECT T1.Template_ID ,  T1.Template_Type_Code  FROM Templates AS T1  JOIN Documents AS T2  ON T1.Template_ID  =  T2.Template_ID  GROUP BY T1.Template_ID  ORDER BY COUNT(*) DESC  LIMIT 1

index is 313
SELECT template_id FROM Documents GROUP BY template_id HAVING count(*)  >  1
Show ids for all templates that are used by more than one document.
SQL generation:
SELECT template_id FROM documents GROUP BY template_id HAVING COUNT(*)  >  1
self correction:
SELECT Template_ID FROM Documents GROUP BY Template_ID HAVING COUNT(Document_ID) > 1

index is 314
SELECT template_id FROM Documents GROUP BY template_id HAVING count(*)  >  1
What are the template ids of any templates used in more than a single document?
SQL generation:
SELECT template_id FROM documents GROUP BY template_id HAVING count(document_id)  >  1
self correction:
SELECT Templates.Template_ID FROM Templates JOIN Documents ON Templates.Template_ID = Documents.Template_ID GROUP BY Templates.Template_ID HAVING COUNT(Documents.Document_ID) > 1

index is 315
SELECT template_id FROM Templates EXCEPT SELECT template_id FROM Documents
Show ids for all templates not used by any document.
SQL generation:
SELECT template_id FROM templates WHERE template_id NOT in (SELECT template_id FROM documents)
self correction:
SELECT Template_ID FROM Templates WHERE Template_ID NOT IN (SELECT Template_ID FROM Documents)

index is 316
SELECT template_id FROM Templates EXCEPT SELECT template_id FROM Documents
What are the ids for templates that are not used in any documents?
SQL generation:
SELECT template_id FROM templates WHERE template_id NOT IN (SELECT template_id FROM documents)
self correction:
SELECT Template_ID FROM Templates WHERE Template_ID NOT IN (SELECT Template_ID FROM Documents)

index is 317
SELECT count(*) FROM Templates
How many templates do we have?
SQL generation:
SELECT COUNT(*) FROM templates
self correction:
SELECT COUNT(DISTINCT Template_ID) FROM Templates

index is 318
SELECT count(*) FROM Templates
Count the number of templates.
SQL generation:
SELECT COUNT(template_id) FROM templates
self correction:
SELECT COUNT(Template_ID) FROM Templates

index is 319
SELECT template_id ,  version_number ,  template_type_code FROM Templates
Show template ids, version numbers, and template type codes for all templates.
SQL generation:
SELECT template_id ,  version_number ,  template_type_code FROM templates
self correction:
SELECT Template_ID, Version_Number, Template_Type_Code FROM Templates

index is 320
SELECT template_id ,  version_number ,  template_type_code FROM Templates
What are the ids, version numbers, and type codes for each template?
SQL generation:
SELECT template_id ,  version_number ,  template_type_code FROM templates
self correction:
SELECT Template_ID ,  Version_Number ,  Template_Type_Code FROM Templates

index is 321
SELECT DISTINCT template_type_code FROM Templates
Show all distinct template type codes for all templates.
SQL generation:
SELECT DISTINCT template_type_code FROM templates
self correction:
SELECT DISTINCT template_type_code FROM Templates

index is 322
SELECT DISTINCT template_type_code FROM Templates
What are the different template type codes?
SQL generation:
SELECT DISTINCT template_type_code FROM templates
self correction:
SELECT DISTINCT Template_Type_Code FROM Ref_Template_Types

index is 323
SELECT template_id FROM Templates WHERE template_type_code  =  "PP" OR template_type_code  =  "PPT"
What are the ids of templates with template type code PP or PPT?
SQL generation:
SELECT template_id FROM templates WHERE template_type_code  =  "PP" OR template_type_code  =  "PPT"
self correction:
SELECT Template_ID FROM Templates WHERE Template_Type_Code  =  "PP" OR Template_Type_Code  =  "PPT"

index is 324
SELECT template_id FROM Templates WHERE template_type_code  =  "PP" OR template_type_code  =  "PPT"
Return the ids of templates that have the code PP or PPT.
SQL generation:
SELECT template_id FROM templates WHERE template_type_code IN ('PP', 'PPT')
self correction:
SELECT Template_ID FROM Templates WHERE Template_Type_Code IN ('PP', 'PPT')

index is 325
SELECT count(*) FROM Templates WHERE template_type_code  =  "CV"
How many templates have template type code CV?
SQL generation:
SELECT COUNT(template_id) FROM templates WHERE template_type_code  =  'CV'
self correction:
SELECT COUNT(DISTINCT Template_ID)  FROM Templates  WHERE Template_Type_Code = 'CV'

index is 326
SELECT count(*) FROM Templates WHERE template_type_code  =  "CV"
Count the number of templates of the type CV.
SQL generation:
SELECT COUNT(Template_ID) FROM Templates WHERE Template_Type_Code = 'CV'
self correction:
SELECT COUNT(DISTINCT Templates.Template_ID)  FROM Templates  JOIN Ref_Template_Types ON Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code WHERE Ref_Template_Types.Template_Type_Code = 'CV'

index is 327
SELECT version_number ,  template_type_code FROM Templates WHERE version_number  >  5
What is the version number and template type code for the template with version number later than 5?
SQL generation:
SELECT version_number ,  template_type_code FROM templates WHERE version_number  >  5
self correction:
SELECT Version_Number, Template_Type_Code FROM Templates WHERE Version_Number > 5

index is 328
SELECT version_number ,  template_type_code FROM Templates WHERE version_number  >  5
Return the version numbers and template type codes of templates with a version number greater than 5.
SQL generation:
SELECT version_number, template_type_code FROM templates WHERE version_number  >  5
self correction:
SELECT Version_Number, Template_Type_Code FROM Templates WHERE Version_Number > 5

index is 329
SELECT template_type_code ,  count(*) FROM Templates GROUP BY template_type_code
Show all template type codes and number of templates for each.
SQL generation:
SELECT COUNT(template_id) ,  template_type_code FROM templates GROUP BY template_type_code
self correction:
SELECT Template_Type_Code, COUNT(Template_ID) FROM Templates GROUP BY Template_Type_Code

index is 330
SELECT template_type_code ,  count(*) FROM Templates GROUP BY template_type_code
What are the different template type codes, and how many templates correspond to each?
SQL generation:
SELECT COUNT(template_id) ,  template_type_code FROM templates GROUP BY template_type_code
self correction:
SELECT Ref_Template_Types.Template_Type_Code, COUNT(DISTINCT Templates.Template_ID) FROM Ref_Template_Types JOIN Templates ON Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code GROUP BY Ref_Template_Types.Template_Type_Code

index is 331
SELECT template_type_code FROM Templates GROUP BY template_type_code ORDER BY count(*) DESC LIMIT 1
Which template type code has most number of templates?
SQL generation:
SELECT template_type_code FROM templates GROUP BY template_type_code ORDER BY COUNT(template_id) DESC LIMIT 1
self correction:
SELECT Template_Type_Code FROM Templates GROUP BY Template_Type_Code ORDER BY COUNT(Template_ID) DESC LIMIT 1

index is 332
SELECT template_type_code FROM Templates GROUP BY template_type_code ORDER BY count(*) DESC LIMIT 1
Return the type code of the template type that the most templates belong to.
SQL generation:
SELECT template_type_code FROM templates GROUP BY template_type_code ORDER BY COUNT(template_id) DESC LIMIT 1
self correction:
SELECT Template_Type_Code FROM Templates GROUP BY Template_Type_Code ORDER BY COUNT(Template_ID) DESC LIMIT 1

index is 333
SELECT template_type_code FROM Templates GROUP BY template_type_code HAVING count(*)  <  3
Show all template type codes with less than three templates.
SQL generation:
SELECT template_type_code FROM templates GROUP BY template_type_code HAVING count(*) < 3
self correction:
SELECT Template_Type_Code  FROM Templates  GROUP BY Template_Type_Code  HAVING COUNT(*) < 3

index is 334
SELECT template_type_code FROM Templates GROUP BY template_type_code HAVING count(*)  <  3
What are the codes of template types that have fewer than 3 templates?
SQL generation:
SELECT template_type_code FROM templates GROUP BY template_type_code HAVING count(template_id)  <  3
self correction:
SELECT Ref_Template_Types.Template_Type_Code  FROM Ref_Template_Types  JOIN Templates ON Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code  GROUP BY Ref_Template_Types.Template_Type_Code  HAVING COUNT(Templates.Template_ID) < 3

index is 335
SELECT min(Version_Number) ,  template_type_code FROM Templates
What the smallest version number and its template type code?
SQL generation:
SELECT version_number , template_type_code FROM templates ORDER BY version_number ASC LIMIT 1
self correction:
SELECT MIN(Version_Number) as smallest_version_number, Template_Type_Code  FROM Templates  GROUP BY Template_Type_Code  ORDER BY smallest_version_number ASC  LIMIT 1

index is 336
SELECT min(Version_Number) ,  template_type_code FROM Templates
Return the lowest version number, along with its corresponding template type code.
SQL generation:
SELECT min(version_number) ,  template_type_code FROM templates
self correction:
SELECT MIN(Templates.Version_Number), Templates.Template_Type_Code  FROM Templates JOIN Ref_Template_Types  ON Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code GROUP BY Templates.Template_Type_Code

index is 337
SELECT T1.template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id WHERE T2.document_name  =  "Data base"
What is the template type code of the template used by document with the name "Data base"?
SQL generation:
SELECT T1.template_type_code FROM templates AS T1 JOIN documents AS T2 ON T1.template_id  =  T2.template_id WHERE T2.document_name  =  'Data base'
self correction:
SELECT T1.Template_Type_Code  FROM Templates AS T1  JOIN Documents AS T2  ON T1.Template_ID = T2.Template_ID  WHERE T2.Document_Name = 'Data base'

index is 338
SELECT T1.template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id WHERE T2.document_name  =  "Data base"
Return the template type code of the template that is used by a document named Data base.
SQL generation:
SELECT T1.template_type_code FROM templates AS T1 JOIN documents AS T2 ON T1.template_id = T2.template_id WHERE T2.document_name  =  'Data base'
self correction:
SELECT T1.Template_Type_Code  FROM Templates AS T1  JOIN Documents AS T2 ON T1.Template_ID = T2.Template_ID  WHERE T2.Document_Name = 'Data base'

index is 339
SELECT T2.document_name FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id WHERE T1.template_type_code  =  "BK"
Show all document names using templates with template type code BK.
SQL generation:
SELECT T1.document_name FROM documents AS T1 JOIN templates AS T2 ON T1.template_id = T2.template_id WHERE T2.template_type_code = "BK"
self correction:
SELECT T1.Document_Name  FROM Documents AS T1  JOIN Templates AS T2  ON T1.Template_ID = T2.Template_ID  WHERE T2.Template_Type_Code = "BK"

index is 340
SELECT T2.document_name FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id WHERE T1.template_type_code  =  "BK"
What are the names of documents that use templates with the code BK?
SQL generation:
SELECT document_name FROM documents JOIN templates ON documents.template_id = templates.template_id WHERE templates.template_type_code  =  'BK'
self correction:
SELECT Document_Name  FROM Documents  JOIN Templates ON Documents.Template_ID = Templates.Template_ID  WHERE Templates.Template_Type_Code  =  'BK'

index is 341
SELECT T1.template_type_code ,  count(*) FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code
Show all template type codes and the number of documents using each type.
SQL generation:
SELECT T1.template_type_code ,  COUNT(T2.document_id) FROM templates AS T1 JOIN documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code
self correction:
SELECT T1.Template_Type_Code, COUNT(DISTINCT T2.Document_ID)  FROM Templates AS T1  JOIN Documents AS T2  ON T1.Template_ID = T2.Template_ID  GROUP BY T1.Template_Type_Code

index is 342
SELECT T1.template_type_code ,  count(*) FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code
What are the different template type codes, and how many documents use each type?
SQL generation:
SELECT COUNT(T2.template_id), T1.template_type_code FROM templates AS T1 JOIN documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code
self correction:
SELECT Ref_Template_Types.Template_Type_Code, COUNT(DISTINCT Documents.Document_ID) FROM Ref_Template_Types JOIN Templates ON Ref_Template_Types.Template_Type_Code = Templates.Template_Type_Code JOIN Documents ON Templates.Template_ID = Documents.Template_ID GROUP BY Ref_Template_Types.Template_Type_Code

index is 343
SELECT T1.template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code ORDER BY count(*) DESC LIMIT 1
Which template type code is used by most number of documents?
SQL generation:
SELECT T1.template_type_code FROM templates AS T1 JOIN documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code ORDER BY count(*) DESC LIMIT 1
self correction:
SELECT T1.template_type_code  FROM Templates AS T1  JOIN Documents AS T2  ON T1.Template_ID = T2.Template_ID  GROUP BY T1.template_type_code  ORDER BY COUNT(*) DESC  LIMIT 1

index is 344
SELECT T1.template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code ORDER BY count(*) DESC LIMIT 1
Return the code of the template type that is most commonly used in documents.
SQL generation:
SELECT T1.template_type_code FROM templates AS T1 JOIN documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code ORDER BY COUNT(*) DESC LIMIT 1
self correction:
SELECT T1.Template_Type_Code  FROM Templates AS T1  JOIN Documents AS T2  ON T1.Template_ID  =  T2.Template_ID  GROUP BY T1.Template_Type_Code  ORDER BY COUNT(*) DESC  LIMIT 1

index is 345
SELECT template_type_code FROM Templates EXCEPT SELECT template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id
Show all template type codes that are not used by any document.
SQL generation:
SELECT template_type_code FROM templates WHERE template_type_code NOT IN (SELECT template_id FROM documents)
self correction:
SELECT template_type_code FROM ref_template_types WHERE template_type_code NOT IN (SELECT template_type_code FROM templates WHERE template_id IN (SELECT template_id FROM documents))

index is 346
SELECT template_type_code FROM Templates EXCEPT SELECT template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id
What are the codes of template types that are not used for any document?
SQL generation:
SELECT template_type_code FROM ref_template_types WHERE template_type_code NOT IN (SELECT template_id FROM documents)
self correction:
SELECT Template_Type_Code  FROM Ref_Template_Types  WHERE Template_Type_Code NOT IN (SELECT Template_Type_Code FROM Templates WHERE Template_ID IN (SELECT Template_ID FROM Documents))

index is 347
SELECT template_type_code ,  template_type_description FROM Ref_template_types
Show all template type codes and descriptions.
SQL generation:
SELECT template_type_code, template_type_description FROM ref_template_types
self correction:
SELECT Template_Type_Code, Template_Type_Description FROM Ref_Template_Types

index is 348
SELECT template_type_code ,  template_type_description FROM Ref_template_types
What are the type codes and descriptions for all template types?
SQL generation:
SELECT template_type_code, template_type_description FROM ref_template_types
self correction:
SELECT template_type_code, template_type_description FROM ref_template_types

index is 349
SELECT template_type_description FROM Ref_template_types WHERE template_type_code  =  "AD"
What is the template type descriptions for template type code "AD".
SQL generation:
SELECT template_type_description FROM ref_template_types WHERE template_type_code  =  "AD"
self correction:
SELECT Template_Type_Description FROM Ref_Template_Types WHERE Template_Type_Code  =  "AD"

index is 350
SELECT template_type_description FROM Ref_template_types WHERE template_type_code  =  "AD"
Return the template type description of the template type with the code AD.
SQL generation:
SELECT template_type_description FROM ref_template_types WHERE template_type_code = 'AD'
self correction:
SELECT Template_Type_Description FROM Ref_Template_Types WHERE Template_Type_Code = 'AD'

index is 351
SELECT template_type_code FROM Ref_template_types WHERE template_type_description  =  "Book"
What is the template type code for template type description "Book".
SQL generation:
SELECT template_type_code FROM ref_template_types WHERE template_type_description  =  "Book"
self correction:
SELECT Template_Type_Code FROM Ref_Template_Types WHERE Template_Type_Description = "Book"

index is 352
SELECT template_type_code FROM Ref_template_types WHERE template_type_description  =  "Book"
Return the type code of the template type with the description "Book".
SQL generation:
SELECT template_type_code FROM ref_template_types WHERE template_type_description  =  'Book'
self correction:
SELECT Template_Type_Code FROM Ref_Template_Types WHERE Template_Type_Description  =  'Book'

index is 353
SELECT DISTINCT T1.template_type_description FROM Ref_template_types AS T1 JOIN Templates AS T2 ON T1.template_type_code  = T2.template_type_code JOIN Documents AS T3 ON T2.Template_ID  =  T3.template_ID
What are the distinct template type descriptions for the templates ever used by any document?
SQL generation:
SELECT DISTINCT template_type_description FROM ref_template_types WHERE template_type_code IN (SELECT template_id FROM documents)
self correction:
SELECT DISTINCT rt.Template_Type_Description FROM Ref_Template_Types rt JOIN Templates t ON rt.Template_Type_Code = t.Template_Type_Code JOIN Documents d ON t.Template_ID = d.Template_ID

index is 354
SELECT DISTINCT T1.template_type_description FROM Ref_template_types AS T1 JOIN Templates AS T2 ON T1.template_type_code  = T2.template_type_code JOIN Documents AS T3 ON T2.Template_ID  =  T3.template_ID
Return the different descriptions for templates that have been used in a document.
SQL generation:
SELECT DISTINCT T1.template_type_description FROM Ref_Template_Types AS T1 JOIN Templates AS T2 ON T1.Template_Type_Code  =  T2.Template_Type_Code JOIN Documents AS T3 ON T2.Template_ID  =  T3.Template_ID
self correction:
SELECT DISTINCT T1.template_type_description  FROM Ref_Template_Types AS T1  JOIN Templates AS T2 ON T1.Template_Type_Code = T2.Template_Type_Code  JOIN Documents AS T3 ON T2.Template_ID = T3.Template_ID

index is 355
SELECT T2.template_id FROM Ref_template_types AS T1 JOIN Templates AS T2 ON T1.template_type_code  = T2.template_type_code WHERE T1.template_type_description  =  "Presentation"
What are the template ids with template type description "Presentation".
SQL generation:
SELECT T2.template_id FROM Ref_Template_Types AS T1 JOIN Templates AS T2 ON T1.Template_Type_Code  =  T2.Template_Type_Code WHERE Template_Type_Description  =  'Presentation'
self correction:
SELECT T2.template_id FROM Ref_Template_Types AS T1 JOIN Templates AS T2 ON T1.Template_Type_Code  =  T2.Template_Type_Code WHERE T1.Template_Type_Description  =  'Presentation'

index is 356
SELECT T2.template_id FROM Ref_template_types AS T1 JOIN Templates AS T2 ON T1.template_type_code  = T2.template_type_code WHERE T1.template_type_description  =  "Presentation"
Return the ids corresponding to templates with the description 'Presentation'.
SQL generation:
SELECT T1.template_id FROM templates AS T1 JOIN ref_template_types AS T2 ON T1.template_type_code  =  T2.template_type_code WHERE T2.template_type_description  =  'Presentation'
self correction:
SELECT T1.Template_ID FROM Templates AS T1 JOIN Ref_Template_Types AS T2 ON T1.Template_Type_Code  =  T2.Template_Type_Code WHERE T2.Template_Type_Description  =  'Presentation'

index is 357
SELECT count(*) FROM Paragraphs
How many paragraphs in total?
SQL generation:
SELECT COUNT(paragraph_id) FROM paragraphs
self correction:
SELECT COUNT(Paragraph_ID) FROM Paragraphs

index is 358
SELECT count(*) FROM Paragraphs
Count the number of paragraphs.
SQL generation:
SELECT COUNT (paragraph_id) FROM paragraphs
self correction:
SELECT COUNT(Paragraph_ID) FROM Paragraphs

index is 359
SELECT count(*) FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_ID  =  T2.document_ID WHERE T2.document_name  =  'Summer Show'
How many paragraphs for the document with name 'Summer Show'?
SQL generation:
SELECT COUNT (paragraph_id) FROM paragraphs WHERE document_id IN (SELECT document_id FROM documents WHERE document_name = 'Summer Show')
self correction:
SELECT COUNT(Paragraph_ID) FROM Paragraphs WHERE Document_ID IN (SELECT Document_ID FROM Documents WHERE Document_Name = 'Summer Show')

index is 360
SELECT count(*) FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_ID  =  T2.document_ID WHERE T2.document_name  =  'Summer Show'
Count the number of paragraphs in the document named 'Summer Show'.
SQL generation:
SELECT COUNT(*) FROM paragraphs JOIN documents ON paragraphs.document_id = documents.document_id WHERE documents.document_name = 'Summer Show'
self correction:
SELECT COUNT(*)  FROM Paragraphs  JOIN Documents  ON Paragraphs.Document_ID = Documents.Document_ID  WHERE Documents.Document_Name = 'Summer Show'

index is 361
select other_details from paragraphs where paragraph_text like 'korea'
Show paragraph details for paragraph with text 'Korea ' .
SQL generation:
SELECT * FROM paragraphs WHERE paragraph_text = 'Korea'
self correction:
SELECT * FROM Paragraphs WHERE Paragraph_Text = 'Korea'

index is 362
select other_details from paragraphs where paragraph_text like 'korea'
What are the details for the paragraph that includes the text 'Korea ' ?
SQL generation:
SELECT * FROM paragraphs WHERE paragraph_text LIKE '%Korea%'
self correction:
SELECT * FROM Paragraphs WHERE Paragraph_Text LIKE '%Korea%'

index is 363
SELECT T1.paragraph_id ,   T1.paragraph_text FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id WHERE T2.Document_Name  =  'Welcome to NY'
Show all paragraph ids and texts for the document with name 'Welcome to NY'.
SQL generation:
SELECT T2.paragraph_id ,  T2.paragraph_text FROM documents AS T1 JOIN paragraphs AS T2 ON T1.document_id  =  T2.document_id WHERE T1.document_name  =  'Welcome to NY'
self correction:
SELECT T2.Paragraph_ID, T2.Paragraph_Text FROM Documents AS T1 JOIN Paragraphs AS T2 ON T1.Document_ID = T2.Document_ID WHERE T1.Document_Name = 'Welcome to NY'

index is 364
SELECT T1.paragraph_id ,   T1.paragraph_text FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id WHERE T2.Document_Name  =  'Welcome to NY'
What are the ids and texts of paragraphs in the document titled 'Welcome to NY'?
SQL generation:
SELECT T1.paragraph_id ,  T1.paragraph_text FROM paragraphs AS T1 JOIN documents AS T2 ON T1.document_id  =  T2.document_id WHERE T2.document_name  =  'Welcome to NY'
self correction:
SELECT T1.Paragraph_ID ,  T1.Paragraph_Text FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.Document_ID  =  T2.Document_ID WHERE T2.Document_Name  =  'Welcome to NY'

index is 365
SELECT T1.paragraph_text FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id WHERE T2.document_name  =  "Customer reviews"
Show all paragraph texts for the document "Customer reviews".
SQL generation:
SELECT T2.paragraph_text FROM documents AS T1 JOIN paragraphs AS T2 ON T1.document_id  =  T2.document_id WHERE T1.document_name  =  'Customer reviews'
self correction:
SELECT T2.Paragraph_Text FROM Documents AS T1 JOIN Paragraphs AS T2 ON T1.Document_ID  =  T2.Document_ID WHERE T1.Document_Name  =  'Customer reviews'

index is 366
SELECT T1.paragraph_text FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id WHERE T2.document_name  =  "Customer reviews"
What are the paragraph texts for the document with the name 'Customer reviews'?
SQL generation:
SELECT T2.paragraph_text FROM documents AS T1 JOIN paragraphs AS T2 ON T1.Document_ID  =  T2.Document_ID WHERE T1.document_name  =  'Customer reviews'
self correction:
SELECT T2.paragraph_text FROM documents AS T1 JOIN paragraphs AS T2 ON T1.Document_ID  =  T2.Document_ID WHERE T1.document_name  =  'Customer reviews'

index is 367
SELECT document_id ,  count(*) FROM Paragraphs GROUP BY document_id ORDER BY document_id
Show all document ids and the number of paragraphs in each document. Order by document id.
SQL generation:
SELECT document_id ,  count(paragraph_id) FROM paragraphs GROUP BY document_id ORDER BY document_id
self correction:
SELECT Document_ID ,  COUNT(Paragraph_ID)  FROM Paragraphs  GROUP BY Document_ID  ORDER BY Document_ID

index is 368
SELECT document_id ,  count(*) FROM Paragraphs GROUP BY document_id ORDER BY document_id
Return the different document ids along with the number of paragraphs corresponding to each, ordered by id.
SQL generation:
SELECT document_id ,  COUNT (paragraph_id) FROM paragraphs GROUP BY document_id ORDER BY document_id
self correction:
SELECT Document_ID, COUNT(Paragraph_ID) FROM Paragraphs GROUP BY Document_ID ORDER BY Document_ID

index is 369
SELECT T1.document_id ,  T2.document_name ,  count(*) FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id GROUP BY T1.document_id
Show all document ids, names and the number of paragraphs in each document.
SQL generation:
SELECT T1.document_id ,  T1.document_name ,  COUNT (T2.paragraph_id) FROM documents AS T1 JOIN paragraphs AS T2 ON T1.document_id  =  T2.document_id GROUP BY T1.document_id ,  T1.document_name
self correction:
SELECT T1.Document_ID, T1.Document_Name, COUNT(T2.Paragraph_ID)  FROM Documents AS T1  JOIN Paragraphs AS T2  ON T1.Document_ID = T2.Document_ID  GROUP BY T1.Document_ID, T1.Document_Name

index is 370
SELECT T1.document_id ,  T2.document_name ,  count(*) FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id GROUP BY T1.document_id
What are the ids and names of each document, as well as the number of paragraphs in each?
SQL generation:
SELECT T1.document_id ,  T1.document_name ,  count(T2.paragraph_id) FROM documents AS T1 JOIN paragraphs AS T2 ON T1.document_id  =  T2.document_id GROUP BY T1.document_id ,  T1.document_name
self correction:
SELECT T1.Document_ID ,  T1.Document_Name ,  COUNT(T2.Paragraph_ID) FROM Documents AS T1 JOIN Paragraphs AS T2 ON T1.Document_ID  =  T2.Document_ID GROUP BY T1.Document_ID ,  T1.Document_Name

index is 371
SELECT document_id FROM Paragraphs GROUP BY document_id HAVING count(*)  >=  2
List all document ids with at least two paragraphs.
SQL generation:
SELECT document_id FROM paragraphs GROUP BY document_id HAVING COUNT (paragraph_id) >= 2
self correction:
SELECT Document_ID FROM Paragraphs GROUP BY Document_ID HAVING COUNT(Paragraph_ID) >= 2

index is 372
SELECT document_id FROM Paragraphs GROUP BY document_id HAVING count(*)  >=  2
What are the ids of documents that have 2 or more paragraphs?
SQL generation:
SELECT document_id FROM paragraphs GROUP BY document_id HAVING count(*) >= 2
self correction:
SELECT Document_ID FROM Paragraphs GROUP BY Document_ID HAVING COUNT(*) >= 2

index is 373
SELECT T1.document_id ,  T2.document_name FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id GROUP BY T1.document_id ORDER BY count(*) DESC LIMIT 1
What is the document id and name with greatest number of paragraphs?
SQL generation:
SELECT T1.document_id ,  T1.document_name FROM documents AS T1 JOIN paragraphs AS T2 ON T1.document_id  =  T2.document_id GROUP BY T1.document_id ORDER BY count(T2.paragraph_id) DESC LIMIT 1
self correction:
SELECT T1.Document_ID ,  T1.Document_Name FROM Documents AS T1 JOIN Paragraphs AS T2 ON T1.Document_ID  =  T2.Document_ID GROUP BY T1.Document_ID, T1.Document_Name ORDER BY count(T2.Paragraph_ID) DESC LIMIT 1

index is 374
SELECT T1.document_id ,  T2.document_name FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id GROUP BY T1.document_id ORDER BY count(*) DESC LIMIT 1
Return the id and name of the document with the most paragraphs.
SQL generation:
SELECT T1.document_id ,  T1.document_name FROM documents AS T1 JOIN paragraphs AS T2 ON T1.document_id  =  T2.document_id GROUP BY T1.document_id ORDER BY count(T2.paragraph_id) DESC LIMIT 1
self correction:
SELECT T1.Document_ID ,  T1.Document_Name FROM Documents AS T1 JOIN Paragraphs AS T2 ON T1.Document_ID  =  T2.Document_ID GROUP BY T1.Document_ID, T1.Document_Name ORDER BY COUNT(T2.Paragraph_ID) DESC LIMIT 1

index is 375
SELECT document_id FROM Paragraphs GROUP BY document_id ORDER BY count(*) ASC LIMIT 1
What is the document id with least number of paragraphs?
SQL generation:
SELECT document_id FROM paragraphs GROUP BY document_id ORDER BY COUNT(*) ASC LIMIT 1
self correction:
SELECT Document_ID FROM Paragraphs GROUP BY Document_ID ORDER BY COUNT(*) ASC LIMIT 1

index is 376
SELECT document_id FROM Paragraphs GROUP BY document_id ORDER BY count(*) ASC LIMIT 1
Return the id of the document with the fewest paragraphs.
SQL generation:
SELECT document_id FROM paragraphs GROUP BY document_id ORDER BY COUNT(paragraph_id) ASC LIMIT 1
self correction:
SELECT Document_ID FROM Paragraphs GROUP BY Document_ID ORDER BY COUNT(Paragraph_ID) ASC LIMIT 1

index is 377
SELECT document_id FROM Paragraphs GROUP BY document_id HAVING count(*) BETWEEN 1 AND 2
What is the document id with 1 to 2 paragraphs?
SQL generation:
SELECT document_id FROM paragraphs GROUP BY document_id HAVING count(*) BETWEEN 1 AND 2
self correction:
SELECT Document_ID FROM Paragraphs GROUP BY Document_ID HAVING COUNT(*) BETWEEN 1 AND 2

index is 378
SELECT document_id FROM Paragraphs GROUP BY document_id HAVING count(*) BETWEEN 1 AND 2
Give the ids of documents that have between one and two paragraphs.
SQL generation:
SELECT document_id FROM paragraphs GROUP BY document_id HAVING count(*) BETWEEN 1 AND 2
self correction:
SELECT Document_ID FROM Paragraphs GROUP BY Document_ID HAVING COUNT(*) BETWEEN 1 AND 2

index is 379
SELECT document_id FROM Paragraphs WHERE paragraph_text  =  'Brazil' INTERSECT SELECT document_id FROM Paragraphs WHERE paragraph_text  =  'Ireland'
Show the document id with paragraph text 'Brazil' and 'Ireland'.
SQL generation:
SELECT document_id FROM paragraphs WHERE paragraph_text LIKE '%Brazil%' AND paragraph_text LIKE '%Ireland%'
self correction:
SELECT Document_ID FROM Paragraphs WHERE Paragraph_Text LIKE '%Brazil%' OR Paragraph_Text LIKE '%Ireland%'

index is 380
SELECT document_id FROM Paragraphs WHERE paragraph_text  =  'Brazil' INTERSECT SELECT document_id FROM Paragraphs WHERE paragraph_text  =  'Ireland'
What are the ids of documents that contain the paragraph text 'Brazil' and 'Ireland'?
SQL generation:
SELECT DISTINCT document_id FROM paragraphs WHERE paragraph_text LIKE '%Brazil%' AND paragraph_text LIKE '%Ireland%'
self correction:
SELECT DISTINCT Document_ID FROM Paragraphs WHERE Paragraph_Text LIKE '%Brazil%' OR Paragraph_Text LIKE '%Ireland%'

index is 381
SELECT count(*) FROM teacher
How many teachers are there?
SQL generation:
SELECT count(*) FROM teacher
self correction:
SELECT count(*) FROM teacher

index is 382
SELECT count(*) FROM teacher
What is the total count of teachers?
SQL generation:
SELECT count(teacher_id) FROM teacher
self correction:
SELECT count(Teacher_ID) FROM teacher

index is 383
SELECT Name FROM teacher ORDER BY Age ASC
List the names of teachers in ascending order of age.
SQL generation:
SELECT name FROM teacher ORDER BY age
self correction:
SELECT name FROM teacher ORDER BY age

index is 384
SELECT Name FROM teacher ORDER BY Age ASC
What are the names of the teachers ordered by ascending age?
SQL generation:
SELECT name FROM teacher ORDER BY age ASC
self correction:
SELECT name FROM teacher ORDER BY age ASC

index is 385
SELECT Age ,  Hometown FROM teacher
What are the age and hometown of teachers?
SQL generation:
SELECT age, hometown FROM teacher
self correction:
SELECT age, hometown FROM teacher

index is 386
SELECT Age ,  Hometown FROM teacher
What is the age and hometown of every teacher?
SQL generation:
SELECT age ,  hometown FROM teacher
self correction:
SELECT age ,  hometown FROM teacher

index is 387
select name from teacher where hometown != "little lever urban district"
List the name of teachers whose hometown is not `` Little Lever Urban District '' .
SQL generation:
SELECT Name FROM teacher WHERE Hometown  <>  'Little Lever Urban District'
self correction:
SELECT Name FROM teacher WHERE Hometown  <>  'Little Lever Urban District'

index is 388
select name from teacher where hometown != "little lever urban district"
What are the names of the teachers whose hometown is not `` Little Lever Urban District '' ?
SQL generation:
SELECT name FROM teacher WHERE hometown  !=  'Little Lever Urban District'
self correction:
SELECT name FROM teacher WHERE hometown  !=  'Little Lever Urban District'

index is 389
SELECT Name FROM teacher WHERE Age  =  32 OR Age  =  33
Show the name of teachers aged either 32 or 33?
SQL generation:
SELECT DISTINCT name FROM teacher WHERE age = 32 OR age = 33
self correction:
SELECT DISTINCT name FROM teacher WHERE age IN (32, 33)

index is 390
SELECT Name FROM teacher WHERE Age  =  32 OR Age  =  33
What are the names of the teachers who are aged either 32 or 33?
SQL generation:
SELECT DISTINCT name FROM teacher WHERE age  =  32 OR age  =  33
self correction:
SELECT DISTINCT name FROM teacher WHERE age  =  32 OR age  =  33

index is 391
SELECT Hometown FROM teacher ORDER BY Age ASC LIMIT 1
What is the hometown of the youngest teacher?
SQL generation:
SELECT hometown FROM teacher WHERE age  =  (SELECT min(age) FROM teacher)
self correction:
SELECT hometown FROM teacher WHERE age  =  (SELECT min(age) FROM teacher)

index is 392
SELECT Hometown FROM teacher ORDER BY Age ASC LIMIT 1
Where is the youngest teacher from?
SQL generation:
SELECT hometown FROM teacher WHERE age  =  (SELECT min(age) FROM teacher)
self correction:
SELECT Hometown FROM teacher WHERE age  =  (SELECT min(age) FROM teacher)

index is 393
SELECT Hometown ,  COUNT(*) FROM teacher GROUP BY Hometown
Show different hometown of teachers and the number of teachers from each hometown.
SQL generation:
SELECT hometown ,  COUNT (name) FROM teacher GROUP BY hometown
self correction:
SELECT Hometown, COUNT(DISTINCT Name) AS NumberOfTeachers FROM teacher GROUP BY Hometown

index is 394
SELECT Hometown ,  COUNT(*) FROM teacher GROUP BY Hometown
For each hometown, how many teachers are there?
SQL generation:
SELECT COUNT(name) ,  hometown FROM teacher GROUP BY hometown
self correction:
SELECT Hometown, COUNT(DISTINCT Teacher_ID)  FROM teacher  GROUP BY Hometown

index is 395
SELECT Hometown FROM teacher GROUP BY Hometown ORDER BY COUNT(*) DESC LIMIT 1
List the most common hometown of teachers.
SQL generation:
SELECT hometown FROM teacher GROUP BY hometown ORDER BY COUNT(*) DESC LIMIT 1
self correction:
SELECT Hometown FROM teacher GROUP BY Hometown ORDER BY COUNT(*) DESC LIMIT 1

index is 396
SELECT Hometown FROM teacher GROUP BY Hometown ORDER BY COUNT(*) DESC LIMIT 1
What is the most commmon hometowns for teachers?
SQL generation:
SELECT hometown FROM teacher GROUP BY hometown ORDER BY COUNT(*) DESC LIMIT 1
self correction:
SELECT Hometown, COUNT(*) as count FROM teacher GROUP BY Hometown ORDER BY count DESC LIMIT 1

index is 397
SELECT Hometown FROM teacher GROUP BY Hometown HAVING COUNT(*)  >=  2
Show the hometowns shared by at least two teachers.
SQL generation:
SELECT hometown FROM teacher GROUP BY hometown HAVING count(*)  >  1
self correction:
SELECT hometown FROM teacher GROUP BY hometown HAVING count(*) > 1

index is 398
SELECT Hometown FROM teacher GROUP BY Hometown HAVING COUNT(*)  >=  2
What are the towns from which at least two teachers come from?
SQL generation:
SELECT hometown FROM teacher GROUP BY hometown HAVING count(*)  >=  2
self correction:
SELECT Hometown FROM teacher GROUP BY Hometown HAVING COUNT(*) >= 2

index is 399
SELECT T3.Name ,  T2.Course FROM course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID  =  T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID  =  T3.Teacher_ID
Show names of teachers and the courses they are arranged to teach.
SQL generation:
SELECT T1.name ,  T2.course FROM teacher AS T1 JOIN course_arrange AS T3 ON T1.Teacher_ID  =  T3.Teacher_ID JOIN course AS T2 ON T3.Course_ID  =  T2.Course_ID
self correction:
SELECT T1.Name ,  T2.Course  FROM teacher AS T1  JOIN course_arrange AS T3 ON T1.Teacher_ID  =  T3.Teacher_ID  JOIN course AS T2 ON T3.Course_ID  =  T2.Course_ID

index is 400
SELECT T3.Name ,  T2.Course FROM course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID  =  T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID  =  T3.Teacher_ID
What is the name of each teacher and what course they teach?
SQL generation:
SELECT T1.name ,  T2.Course FROM teacher AS T1 JOIN course_arrange AS T2 ON T1.Teacher_ID  =  T2.Teacher_ID
self correction:
SELECT T1.Name, C.Course FROM teacher AS T1 JOIN course_arrange AS CA ON T1.Teacher_ID = CA.Teacher_ID JOIN course AS C ON CA.Course_ID = C.Course_ID

index is 401
SELECT T3.Name ,  T2.Course FROM course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID  =  T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID  =  T3.Teacher_ID ORDER BY T3.Name
Show names of teachers and the courses they are arranged to teach in ascending alphabetical order of the teacher's name.
SQL generation:
SELECT T1.name ,  T2.course FROM teacher AS T1 JOIN course_arrange AS T3 ON T1.Teacher_ID  =  T3.Teacher_ID JOIN course AS T2 ON T3.Course_ID  =  T2.Course_ID ORDER BY T1.name
self correction:
SELECT T1.Name ,  T2.Course  FROM teacher AS T1  JOIN course_arrange AS T3 ON T1.Teacher_ID  =  T3.Teacher_ID  JOIN course AS T2 ON T3.Course_ID  =  T2.Course_ID  ORDER BY T1.Name ASC

index is 402
SELECT T3.Name ,  T2.Course FROM course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID  =  T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID  =  T3.Teacher_ID ORDER BY T3.Name
What are the names of the teachers and the courses they teach in ascending alphabetical order by the name of the teacher?
SQL generation:
SELECT T1.name, T3.course FROM teacher AS T1 JOIN course_arrange AS T2 ON T1.teacher_id = T2.teacher_id JOIN course AS T3 ON T2.course_id = T3.course_id ORDER BY T1.name
self correction:
SELECT T1.name, T3.course FROM teacher AS T1 JOIN course_arrange AS T2 ON T1.teacher_id = T2.teacher_id JOIN course AS T3 ON T2.course_id = T3.course_id ORDER BY T1.name

index is 403
SELECT T3.Name FROM course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID  =  T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID  =  T3.Teacher_ID WHERE T2.Course  =  "Math"
Show the name of the teacher for the math course.
SQL generation:
SELECT T1.name FROM teacher AS T1 JOIN course_arrange AS T2 ON T1.Teacher_ID = T2.Teacher_ID JOIN course AS T3 ON T2.Course_ID = T3.Course_ID WHERE T3.Course = 'Math'
self correction:
SELECT T1.Name FROM teacher AS T1 JOIN course_arrange AS T2 ON T1.Teacher_ID = T2.Teacher_ID JOIN course AS T3 ON T2.Course_ID = T3.Course_ID WHERE T3.Course = 'Math'

index is 404
SELECT T3.Name FROM course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID  =  T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID  =  T3.Teacher_ID WHERE T2.Course  =  "Math"
What are the names of the people who teach math courses?
SQL generation:
SELECT DISTINCT T1.name FROM teacher AS T1 JOIN course_arrange AS T2 ON T1.teacher_id  =  T2.teacher_id JOIN course AS T3 ON T2.course_id  =  T3.course_id WHERE T3.course  =  'Math'
self correction:
SELECT DISTINCT T1.Name FROM teacher AS T1 JOIN course_arrange AS T2 ON T1.Teacher_ID  =  T2.Teacher_ID JOIN course AS T3 ON T2.Course_ID  =  T3.Course_ID WHERE T3.Course  =  'Math'

index is 405
SELECT T2.Name ,  COUNT(*) FROM course_arrange AS T1 JOIN teacher AS T2 ON T1.Teacher_ID  =  T2.Teacher_ID GROUP BY T2.Name
Show names of teachers and the number of courses they teach.
SQL generation:
SELECT teacher.name ,  COUNT(course_arrange.Course_ID) FROM teacher JOIN course_arrange ON teacher.Teacher_ID  =  course_arrange.Teacher_ID GROUP BY teacher.name
self correction:
SELECT teacher.Name, COUNT(course_arrange.Course_ID)  FROM teacher  JOIN course_arrange ON teacher.Teacher_ID = course_arrange.Teacher_ID  GROUP BY teacher.Teacher_ID, teacher.Name

index is 406
SELECT T2.Name ,  COUNT(*) FROM course_arrange AS T1 JOIN teacher AS T2 ON T1.Teacher_ID  =  T2.Teacher_ID GROUP BY T2.Name
What are the names of the teachers and how many courses do they teach?
SQL generation:
SELECT T1.Name, COUNT(T2.Course_ID) FROM teacher AS T1 JOIN course_arrange AS T2 ON T1.Teacher_ID = T2.Teacher_ID GROUP BY T1.Name
self correction:
SELECT T1.Name, COUNT(DISTINCT T2.Course_ID)  FROM teacher AS T1  JOIN course_arrange AS T2  ON T1.Teacher_ID = T2.Teacher_ID  GROUP BY T1.Teacher_ID, T1.Name

index is 407
SELECT T2.Name FROM course_arrange AS T1 JOIN teacher AS T2 ON T1.Teacher_ID  =  T2.Teacher_ID GROUP BY T2.Name HAVING COUNT(*)  >=  2
Show names of teachers that teach at least two courses.
SQL generation:
SELECT T1.name FROM teacher AS T1 JOIN course_arrange AS T2 ON T1.Teacher_ID  =  T2.Teacher_ID GROUP BY T1.name HAVING count(*) >= 2
self correction:
SELECT T1.Name  FROM teacher AS T1  JOIN course_arrange AS T2  ON T1.Teacher_ID  =  T2.Teacher_ID  GROUP BY T1.Teacher_ID  HAVING COUNT(DISTINCT T2.Course_ID) >= 2

index is 408
SELECT T2.Name FROM course_arrange AS T1 JOIN teacher AS T2 ON T1.Teacher_ID  =  T2.Teacher_ID GROUP BY T2.Name HAVING COUNT(*)  >=  2
What are the names of the teachers who teach at least two courses?
SQL generation:
SELECT T1.name FROM teacher AS T1 JOIN course_arrange AS T2 ON T1.Teacher_ID  =  T2.Teacher_ID GROUP BY T1.name HAVING COUNT(*) >= 2
self correction:
SELECT T1.Name  FROM teacher AS T1  JOIN course_arrange AS T2 ON T1.Teacher_ID = T2.Teacher_ID  GROUP BY T1.Teacher_ID, T1.Name  HAVING COUNT(DISTINCT T2.Course_ID) >= 2

index is 409
SELECT Name FROM teacher WHERE Teacher_id NOT IN (SELECT Teacher_id FROM course_arrange)
List the names of teachers who have not been arranged to teach courses.
SQL generation:
SELECT name FROM teacher WHERE Teacher_ID NOT IN (SELECT Teacher_ID FROM course_arrange)
self correction:
SELECT name FROM teacher WHERE Teacher_ID NOT IN (SELECT Teacher_ID FROM course_arrange)

index is 410
SELECT Name FROM teacher WHERE Teacher_id NOT IN (SELECT Teacher_id FROM course_arrange)
What are the names of the teachers whose courses have not been arranged?
SQL generation:
SELECT DISTINCT name FROM teacher WHERE Teacher_ID NOT IN (SELECT Teacher_ID FROM course_arrange)
self correction:
SELECT DISTINCT name FROM teacher WHERE Teacher_ID NOT IN (SELECT Teacher_ID FROM course_arrange)

index is 411
SELECT count(*) FROM visitor WHERE age  <  30
How many visitors below age 30 are there?
SQL generation:
SELECT COUNT(ID) FROM visitor WHERE Age < 30
self correction:
SELECT COUNT(ID) FROM visitor WHERE Age < 30

index is 412
SELECT name FROM visitor WHERE Level_of_membership  >  4 ORDER BY Level_of_membership DESC
Find the names of the visitors whose membership level is higher than 4, and order the results by the level from high to low.
SQL generation:
SELECT name FROM visitor WHERE level_of_membership > 4 ORDER BY level_of_membership DESC
self correction:
SELECT Name FROM visitor WHERE Level_of_membership > 4 ORDER BY Level_of_membership DESC

index is 413
SELECT avg(age) FROM visitor WHERE Level_of_membership  <=  4
What is the average age of the visitors whose membership level is not higher than 4?
SQL generation:
SELECT AVG (age) FROM visitor WHERE level_of_membership  <=  4
self correction:
SELECT AVG(Age) FROM visitor WHERE Level_of_membership  <=  4

index is 414
SELECT name ,  Level_of_membership FROM visitor WHERE Level_of_membership  >  4 ORDER BY age DESC
Find the name and membership level of the visitors whose membership level is higher than 4, and sort by their age from old to young.
SQL generation:
SELECT name ,  level_of_membership FROM visitor WHERE level_of_membership  >  4 ORDER BY age DESC
self correction:
SELECT Name ,  Level_of_membership FROM visitor WHERE Level_of_membership  >  4 ORDER BY Age DESC

index is 415
SELECT museum_id ,  name FROM museum ORDER BY num_of_staff DESC LIMIT 1
Find the id and name of the museum that has the most staff members?
SQL generation:
SELECT Museum_ID ,  Name FROM museum ORDER BY Num_of_Staff DESC LIMIT 1
self correction:
SELECT Museum_ID ,  Name FROM museum ORDER BY Num_of_Staff DESC LIMIT 1

index is 416
SELECT avg(num_of_staff) FROM museum WHERE open_year  <  2009
Find the average number of staff working for the museums that were open before 2009.
SQL generation:
SELECT AVG(num_of_staff) FROM museum WHERE open_year < 2009
self correction:
SELECT AVG(Num_of_Staff) FROM museum WHERE Open_Year < 2009

index is 417
SELECT Num_of_Staff ,  Open_Year FROM museum WHERE name  =  'Plaza Museum'
What are the opening year and staff number of the museum named Plaza Museum?
SQL generation:
SELECT open_year ,  num_of_staff FROM museum WHERE name  =  'Plaza Museum'
self correction:
SELECT Open_Year , Num_of_Staff FROM museum WHERE Name = 'Plaza Museum'

index is 418
SELECT name FROM museum WHERE num_of_staff  >  (SELECT min(num_of_staff) FROM museum WHERE open_year  >  2010)
find the names of museums which have more staff than the minimum staff number of all museums opened after 2010.
SQL generation:
SELECT name FROM museum WHERE num_of_staff >  (SELECT min(num_of_staff) FROM museum WHERE open_year  >  2010)
self correction:
SELECT Name FROM museum WHERE Num_of_Staff >  (SELECT MIN(Num_of_Staff) FROM museum WHERE Open_Year > 2010)

index is 419
SELECT t1.id ,  t1.name ,  t1.age FROM visitor AS t1 JOIN visit AS t2 ON t1.id  =  t2.visitor_id GROUP BY t1.id HAVING count(*)  >  1
find the id, name and age for visitors who visited some museums more than once.
SQL generation:
SELECT T1.id, T1.name, T1.age FROM visitor AS T1 JOIN visit AS T2 ON T1.id = T2.visitor_id GROUP BY T1.id HAVING COUNT(T2.museum_id) > 1
self correction:
SELECT T1.ID, T1.Name, T1.Age  FROM visitor AS T1  JOIN visit AS T2  ON T1.ID = T2.visitor_ID  GROUP BY T1.ID, T1.Name, T1.Age  HAVING COUNT(DISTINCT T2.Museum_ID) > 1

index is 420
SELECT t2.visitor_id ,  t1.name ,  t1.Level_of_membership FROM visitor AS t1 JOIN visit AS t2 ON t1.id  =  t2.visitor_id GROUP BY t2.visitor_id ORDER BY sum(t2.Total_spent) DESC LIMIT 1
What are the id, name and membership level of visitors who have spent the largest amount of money in total in all museum tickets?
SQL generation:
SELECT T1.id ,  T1.name ,  T1.level_of_membership FROM visitor AS T1 JOIN visit AS T2 ON T1.id  =  T2.visitor_id WHERE T2.total_spent  =  (SELECT max(total_spent) FROM visit)
self correction:
SELECT T1.ID, T1.Name, T1.Level_of_membership  FROM visitor AS T1  JOIN visit AS T2  ON T1.ID = T2.visitor_ID  GROUP BY T1.ID  HAVING SUM(T2.Total_spent) =       (SELECT MAX(Sum_spent) FROM           (SELECT visitor_ID, SUM(Total_spent) AS Sum_spent         FROM visit          GROUP BY visitor_ID))

index is 421
SELECT t2.Museum_ID ,  t1.name FROM museum AS t1 JOIN visit AS t2 ON t1.Museum_ID  =  t2.Museum_ID GROUP BY t2.Museum_ID ORDER BY count(*) DESC LIMIT 1
What are the id and name of the museum visited most times?
SQL generation:
SELECT T1.museum_id ,  T1.name FROM museum AS T1 JOIN visit AS T2 ON T1.museum_id  =  T2.museum_id GROUP BY T1.museum_id ,  T1.name ORDER BY count(*) DESC LIMIT 1
self correction:
SELECT T1.Museum_ID, T1.Name  FROM museum AS T1  JOIN visit AS T2  ON T1.Museum_ID = T2.Museum_ID  GROUP BY T1.Museum_ID ORDER BY COUNT(*) DESC  LIMIT 1

index is 422
SELECT name FROM museum WHERE Museum_ID NOT IN (SELECT museum_id FROM visit)
What is the name of the museum that had no visitor yet?
SQL generation:
SELECT name FROM museum WHERE Museum_ID NOT IN (SELECT Museum_ID FROM visit)
self correction:
SELECT Name FROM museum WHERE Museum_ID NOT IN (SELECT Museum_ID FROM visit)

index is 423
SELECT t1.name ,  t1.age FROM visitor AS t1 JOIN visit AS t2 ON t1.id  =  t2.visitor_id ORDER BY t2.num_of_ticket DESC LIMIT 1
Find the name and age of the visitor who bought the most tickets at once.
SQL generation:
SELECT T1.name ,  T1.age FROM visitor AS T1 JOIN visit AS T2 ON T1.id  =  T2.visitor_id WHERE T2.num_of_ticket  =  (SELECT max(num_of_ticket) FROM visit)
self correction:
SELECT T1.Name, T1.Age  FROM visitor AS T1  JOIN visit AS T2 ON T1.ID = T2.visitor_ID  WHERE T2.Num_of_Ticket = (SELECT MAX(Num_of_Ticket) FROM visit)

index is 424
SELECT avg(num_of_ticket) ,  max(num_of_ticket) FROM visit
What are the average and maximum number of tickets bought in all visits?
SQL generation:
SELECT AVG(num_of_ticket), MAX(num_of_ticket) FROM visit
self correction:
SELECT AVG(Num_of_Ticket), MAX(Num_of_Ticket) FROM visit

index is 425
SELECT sum(t2.Total_spent) FROM visitor AS t1 JOIN visit AS t2 ON t1.id  =  t2.visitor_id WHERE t1.Level_of_membership  =  1
What is the total ticket expense of the visitors whose membership level is 1?
SQL generation:
SELECT SUM(T2.total_spent) FROM visitor AS T1 JOIN visit AS T2 ON T1.id = T2.visitor_id WHERE level_of_membership = 1
self correction:
SELECT SUM(T2.Total_spent)  FROM visitor AS T1  JOIN visit AS T2  ON T1.ID = T2.visitor_ID  WHERE T1.Level_of_membership = 1

index is 426
SELECT t1.name FROM visitor AS t1 JOIN visit AS t2 ON t1.id  =  t2.visitor_id JOIN museum AS t3 ON t3.Museum_ID  =  t2.Museum_ID WHERE t3.open_year  <  2009 INTERSECT SELECT t1.name FROM visitor AS t1 JOIN visit AS t2 ON t1.id  =  t2.visitor_id JOIN museum AS t3 ON t3.Museum_ID  =  t2.Museum_ID WHERE t3.open_year  >  2011
What is the name of the visitor who visited both a museum opened before 2009 and a museum opened after 2011?
SQL generation:
SELECT T1.name FROM visitor AS T1 WHERE id IN (SELECT visitor_id FROM visit AS T2 JOIN museum AS T3 ON T2.Museum_ID  =  T3.Museum_ID WHERE T3.open_year < 2009) AND id IN (SELECT visitor_id FROM visit AS T4 JOIN museum AS T5 ON T4.Museum_ID  =  T5.Museum_ID WHERE T5.open_year > 2011)
self correction:
SELECT T1.Name FROM visitor AS T1 WHERE T1.ID IN (SELECT T2.visitor_ID FROM visit AS T2 JOIN museum AS T3 ON T2.Museum_ID  =  T3.Museum_ID WHERE T3.Open_Year < 2009) AND T1.ID IN (SELECT T4.visitor_ID FROM visit AS T4 JOIN museum AS T5 ON T4.Museum_ID  =  T5.Museum_ID WHERE T5.Open_Year > 2011)

index is 427
SELECT count(*) FROM visitor WHERE id NOT IN (SELECT t2.visitor_id FROM museum AS t1 JOIN visit AS t2 ON t1.Museum_ID  =  t2.Museum_ID WHERE t1.open_year  >  2010)
Find the number of visitors who did not visit any museum opened after 2010.
SQL generation:
SELECT COUNT(DISTINCT id) FROM visitor WHERE id NOT IN (SELECT visitor_id FROM visit JOIN museum ON visit.Museum_ID  =  museum.Museum_ID WHERE Open_Year > 2010)
self correction:
SELECT COUNT(DISTINCT ID)  FROM visitor  WHERE ID NOT IN (     SELECT visitor_ID      FROM visit      JOIN museum ON visit.Museum_ID = museum.Museum_ID      WHERE museum.Open_Year > 2010 )

index is 428
SELECT count(*) FROM museum WHERE open_year  >  2013 OR open_year  <  2008
How many museums were opened after 2013 or before 2008?
SQL generation:
SELECT COUNT(*) FROM museum WHERE open_year > 2013 OR open_year < 2008
self correction:
SELECT COUNT(*) FROM museum WHERE Open_Year > 2013 OR Open_Year < 2008

index is 429
SELECT count(*) FROM players
Find the total number of players.
SQL generation:
SELECT COUNT(player_id) FROM players
self correction:
SELECT COUNT(DISTINCT player_id) FROM players

index is 430
SELECT count(*) FROM players
How many players are there?
SQL generation:
SELECT COUNT (DISTINCT player_id) FROM players
self correction:
SELECT COUNT (DISTINCT player_id) FROM players

index is 431
SELECT count(*) FROM matches
Find the total number of matches.
SQL generation:
SELECT COUNT(*) FROM matches
self correction:
SELECT COUNT(*) FROM matches

index is 432
SELECT count(*) FROM matches
Count the number of matches.
SQL generation:
SELECT count(*) FROM matches
self correction:
SELECT count(*) FROM matches

index is 433
SELECT first_name ,  birth_date FROM players WHERE country_code  =  'USA'
List the first name and birth date of all players from the country with code USA.
SQL generation:
SELECT first_name ,  birth_date FROM players WHERE country_code  =  'USA'
self correction:
SELECT first_name, birth_date FROM players WHERE country_code = 'USA'

index is 434
SELECT first_name ,  birth_date FROM players WHERE country_code  =  'USA'
What are the first names and birth dates of players from the USA?
SQL generation:
SELECT first_name ,  birth_date FROM players WHERE country_code  =  'USA'
self correction:
SELECT first_name ,  birth_date FROM players WHERE country_code  =  'USA'

index is 435
SELECT avg(loser_age) ,  avg(winner_age) FROM matches
Find the average age of losers and winners of all matches.
SQL generation:
SELECT AVG(loser_age), AVG(winner_age) FROM matches
self correction:
SELECT AVG(loser_age), AVG(winner_age) FROM matches

index is 436
SELECT avg(loser_age) ,  avg(winner_age) FROM matches
What are the average ages of losers and winners across matches?
SQL generation:
SELECT AVG (loser_age) ,  AVG (winner_age) FROM matches
self correction:
SELECT AVG(loser_age), AVG(winner_age) FROM matches

index is 437
SELECT avg(winner_rank) FROM matches
Find the average rank of winners in all matches.
SQL generation:
SELECT AVG(winner_rank) FROM matches
self correction:
SELECT AVG(winner_rank) FROM matches

index is 438
SELECT avg(winner_rank) FROM matches
What is the average rank for winners in all matches?
SQL generation:
SELECT AVG (winner_rank) FROM matches
self correction:
SELECT AVG(winner_rank) FROM matches

index is 439
SELECT min(loser_rank) FROM matches
Find the highest rank of losers in all matches.
SQL generation:
SELECT max(loser_rank) FROM matches
self correction:
SELECT max(loser_rank)  FROM matches

index is 440
SELECT min(loser_rank) FROM matches
What is the best rank of losers across all matches?
SQL generation:
SELECT MIN(loser_rank) FROM matches
self correction:
SELECT MIN(rankings.ranking)  FROM matches INNER JOIN rankings ON matches.loser_id = rankings.player_id

index is 441
SELECT count(DISTINCT country_code) FROM players
find the number of distinct country codes of all players.
SQL generation:
SELECT COUNT(DISTINCT country_code) FROM players
self correction:
SELECT COUNT(DISTINCT country_code) FROM players

index is 442
SELECT count(DISTINCT country_code) FROM players
How many distinct countries do players come from?
SQL generation:
SELECT COUNT(DISTINCT country_code) FROM players
self correction:
SELECT COUNT(DISTINCT country_code) FROM players

index is 443
SELECT count(DISTINCT loser_name) FROM matches
Find the number of distinct name of losers.
SQL generation:
SELECT COUNT (DISTINCT loser_name) FROM matches
self correction:
SELECT COUNT (DISTINCT loser_name) FROM matches

index is 444
SELECT count(DISTINCT loser_name) FROM matches
How many different loser names are there?
SQL generation:
SELECT COUNT(DISTINCT loser_name) FROM matches
self correction:
SELECT COUNT(DISTINCT loser_name) FROM matches

index is 445
SELECT tourney_name FROM matches GROUP BY tourney_name HAVING count(*)  >  10
Find the name of tourney that has more than 10 matches.
SQL generation:
SELECT tourney_name FROM matches GROUP BY tourney_name HAVING count(*) > 10
self correction:
SELECT tourney_name FROM matches GROUP BY tourney_name HAVING count(*) > 10

index is 446
SELECT tourney_name FROM matches GROUP BY tourney_name HAVING count(*)  >  10
What are the names of tournaments that have more than 10 matches?
SQL generation:
SELECT tourney_name FROM matches GROUP BY tourney_name HAVING count(*) > 10
self correction:
SELECT tourney_name FROM matches GROUP BY tourney_name HAVING count(*) > 10

index is 447
SELECT winner_name FROM matches WHERE YEAR  =  2013 INTERSECT SELECT winner_name FROM matches WHERE YEAR  =  2016
List the names of all winners who played in both 2013 and 2016.
SQL generation:
SELECT DISTINCT winner_name FROM matches WHERE winner_id IN (SELECT winner_id FROM matches WHERE year  =  2013) AND winner_id IN (SELECT winner_id FROM matches WHERE year  =  2016)
self correction:
SELECT DISTINCT winner_name  FROM matches  WHERE year IN (2013, 2016) GROUP BY winner_id HAVING COUNT(DISTINCT year) = 2

index is 448
SELECT winner_name FROM matches WHERE YEAR  =  2013 INTERSECT SELECT winner_name FROM matches WHERE YEAR  =  2016
What are the names of players who won in both 2013 and 2016?
SQL generation:
SELECT first_name, last_name FROM players WHERE player_id IN (SELECT winner_id FROM matches WHERE year  =  2013) AND player_id IN (SELECT winner_id FROM matches WHERE year  =  2016)
self correction:
SELECT DISTINCT first_name, last_name  FROM players  WHERE player_id IN (SELECT winner_id FROM matches WHERE year  =  2013)  AND player_id IN (SELECT winner_id FROM matches WHERE year  =  2016)

index is 449
SELECT count(*) FROM matches WHERE YEAR  =  2013 OR YEAR  =  2016
List the number of all matches who played in years of 2013 or 2016.
SQL generation:
SELECT COUNT(*) FROM matches WHERE year = 2013 OR year = 2016
self correction:
SELECT COUNT(*) FROM matches WHERE year = 2013 OR year = 2016

index is 450
SELECT count(*) FROM matches WHERE YEAR  =  2013 OR YEAR  =  2016
How many matches were played in 2013 or 2016?
SQL generation:
SELECT COUNT(*) FROM matches WHERE year  =  2013 OR year  =  2016
self correction:
SELECT COUNT(*) FROM matches WHERE year  =  2013 OR year  =  2016

index is 451
SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN matches AS T2 ON T1.player_id  =  T2.winner_id WHERE T2.tourney_name  =  'WTA Championships' INTERSECT SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN matches AS T2 ON T1.player_id  =  T2.winner_id WHERE T2.tourney_name  =  'Australian Open'
What are the country code and first name of the players who won in both tourney WTA Championships and Australian Open?
SQL generation:
SELECT T1.country_code, T1.first_name FROM players AS T1 WHERE T1.player_id IN (SELECT T2.winner_id FROM matches AS T2 WHERE T2.tourney_name  =  'WTA Championships') AND T1.player_id IN (SELECT T3.winner_id FROM matches AS T3 WHERE T3.tourney_name  =  'Australian Open')
self correction:
SELECT DISTINCT players.country_code, players.first_name  FROM players  JOIN matches AS m1 ON players.player_id = m1.winner_id  JOIN matches AS m2 ON players.player_id = m2.winner_id  WHERE m1.tourney_name = 'WTA Championships'  AND m2.tourney_name = 'Australian Open'

index is 452
SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN matches AS T2 ON T1.player_id  =  T2.winner_id WHERE T2.tourney_name  =  'WTA Championships' INTERSECT SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN matches AS T2 ON T1.player_id  =  T2.winner_id WHERE T2.tourney_name  =  'Australian Open'
What are the first names and country codes for players who won both the WTA Championships and the Australian Open?
SQL generation:
SELECT DISTINCT first_name ,  country_code FROM players WHERE player_id IN (SELECT winner_id FROM matches WHERE tourney_name  =  'WTA Championships') AND player_id IN (SELECT winner_id FROM matches WHERE tourney_name  =  'Australian Open')
self correction:
SELECT DISTINCT first_name ,  country_code  FROM players  WHERE player_id IN (     SELECT winner_id      FROM matches      WHERE tourney_name  =  'WTA Championships' )  AND player_id IN (     SELECT winner_id      FROM matches      WHERE tourney_name  =  'Australian Open' )

index is 453
SELECT first_name ,  country_code FROM players ORDER BY birth_date LIMIT 1
Find the first name and country code of the oldest player.
SQL generation:
SELECT first_name ,  country_code FROM players ORDER BY birth_date ASC LIMIT 1
self correction:
SELECT first_name ,  country_code FROM players ORDER BY birth_date ASC LIMIT 1

index is 454
SELECT first_name ,  country_code FROM players ORDER BY birth_date LIMIT 1
What is the first name and country code of the oldest player?
SQL generation:
SELECT first_name ,  country_code FROM players ORDER BY birth_date ASC LIMIT 1
self correction:
SELECT first_name, country_code FROM players ORDER BY birth_date LIMIT 1

index is 455
SELECT first_name ,  last_name FROM players ORDER BY birth_date
List the first and last name of all players in the order of birth date.
SQL generation:
SELECT first_name ,  last_name FROM players ORDER BY birth_date
self correction:
SELECT first_name ,  last_name FROM players ORDER BY birth_date

index is 456
SELECT first_name ,  last_name FROM players ORDER BY birth_date
What are the full names of all players, sorted by birth date?
SQL generation:
SELECT first_name ,  last_name FROM players ORDER BY birth_date
self correction:
SELECT first_name ,  last_name FROM players ORDER BY birth_date

index is 457
SELECT first_name ,  last_name FROM players WHERE hand  =  'L' ORDER BY birth_date
List the first and last name of all players who are left / L hand in the order of birth date.
SQL generation:
SELECT first_name ,  last_name FROM players WHERE hand  =  'L' ORDER BY birth_date
self correction:
SELECT first_name, last_name FROM players WHERE hand = 'L' ORDER BY birth_date

index is 458
SELECT first_name ,  last_name FROM players WHERE hand  =  'L' ORDER BY birth_date
What are the full names of all left handed players, in order of birth date?
SQL generation:
SELECT first_name ,  last_name ,  birth_date FROM players WHERE hand  =  'L' ORDER BY birth_date
self correction:
SELECT first_name, last_name, birth_date FROM players WHERE hand = 'L' ORDER BY birth_date

index is 459
SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id ORDER BY T2.tours DESC LIMIT 1
Find the first name and country code of the player who did the most number of tours.
SQL generation:
SELECT T1.first_name ,  T1.country_code FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id ORDER BY T2.tours DESC LIMIT 1
self correction:
SELECT T1.first_name ,  T1.country_code  FROM players AS T1  JOIN (     SELECT player_id, MAX(tours) as max_tours      FROM rankings      GROUP BY player_id ) AS T2  ON T1.player_id = T2.player_id  ORDER BY T2.max_tours DESC  LIMIT 1

index is 460
SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id ORDER BY T2.tours DESC LIMIT 1
What is the first name and country code of the player with the most tours?
SQL generation:
SELECT T2.first_name ,  T2.country_code FROM rankings AS T1 JOIN players AS T2 ON T1.player_id  =  T2.player_id WHERE T1.tours  =  (SELECT max(tours) FROM rankings)
self correction:
SELECT T2.first_name ,  T2.country_code FROM rankings AS T1 JOIN players AS T2 ON T1.player_id  =  T2.player_id WHERE T1.tours  =  (SELECT max(tours) FROM rankings)

index is 461
SELECT YEAR FROM matches GROUP BY YEAR ORDER BY count(*) DESC LIMIT 1
Find the year that has the most number of matches.
SQL generation:
SELECT year FROM matches GROUP BY year ORDER BY count(*) DESC LIMIT 1
self correction:
SELECT year FROM matches GROUP BY year ORDER BY count(*) DESC LIMIT 1

index is 462
SELECT YEAR FROM matches GROUP BY YEAR ORDER BY count(*) DESC LIMIT 1
Which year had the most matches?
SQL generation:
SELECT year FROM matches GROUP BY year ORDER BY COUNT(year) DESC LIMIT 1
self correction:
SELECT year FROM matches GROUP BY year ORDER BY COUNT(*) DESC LIMIT 1

index is 463
SELECT winner_name ,  winner_rank_points FROM matches GROUP BY winner_name ORDER BY count(*) DESC LIMIT 1
Find the name and rank points of the winner who won the most times.
SQL generation:
SELECT winner_name ,  winner_rank_points FROM matches GROUP BY winner_id ORDER BY count(*) DESC LIMIT 1
self correction:
SELECT winner_name ,  winner_rank_points FROM matches GROUP BY winner_name ORDER BY count(*) DESC LIMIT 1

index is 464
SELECT winner_name ,  winner_rank_points FROM matches GROUP BY winner_name ORDER BY count(*) DESC LIMIT 1
What is the name of the winner who has won the most matches, and how many rank points does this player have?
SQL generation:
SELECT T1.winner_name ,  T2.ranking_points FROM matches AS T1 JOIN rankings AS T2 ON T1.winner_id  =  T2.player_id GROUP BY T1.winner_name ORDER BY count(*) DESC LIMIT 1
self correction:
SELECT T1.winner_name, MAX(T2.ranking_points)  FROM matches AS T1  JOIN rankings AS T2 ON T1.winner_id = T2.player_id  GROUP BY T1.winner_name  ORDER BY COUNT(T1.winner_name) DESC  LIMIT 1

index is 465
SELECT winner_name FROM matches WHERE tourney_name  =  'Australian Open' ORDER BY winner_rank_points DESC LIMIT 1
Find the name of the winner who has the highest rank points and participated in the Australian Open tourney.
SQL generation:
SELECT winner_name FROM matches WHERE tourney_name = 'Australian Open' ORDER BY winner_rank_points DESC LIMIT 1
self correction:
SELECT first_name || ' ' || last_name AS winner_name FROM matches JOIN players ON matches.winner_id = players.player_id WHERE matches.tourney_name = 'Australian Open' ORDER BY matches.winner_rank_points DESC  LIMIT 1

index is 466
SELECT winner_name FROM matches WHERE tourney_name  =  'Australian Open' ORDER BY winner_rank_points DESC LIMIT 1
What is the name of the winner with the most rank points who participated in the Australian Open tournament?
SQL generation:
SELECT winner_name FROM matches WHERE tourney_name = 'Australian Open' ORDER BY winner_rank_points DESC LIMIT 1
self correction:
SELECT players.first_name, players.last_name  FROM matches  JOIN players ON matches.winner_id = players.player_id  WHERE matches.tourney_name = 'Australian Open'  ORDER BY matches.winner_rank_points DESC  LIMIT 1

index is 467
SELECT winner_name ,  loser_name FROM matches ORDER BY minutes DESC LIMIT 1
find the names of loser and winner who played in the match with greatest number of minutes.
SQL generation:
SELECT loser_name ,  winner_name FROM matches WHERE minutes  =  (SELECT max(minutes) FROM matches)
self correction:
SELECT loser_name ,  winner_name FROM matches WHERE minutes  =  (SELECT max(minutes) FROM matches)

index is 468
SELECT winner_name ,  loser_name FROM matches ORDER BY minutes DESC LIMIT 1
What are the names of the winner and loser who played in the longest match?
SQL generation:
SELECT winner_name ,  loser_name FROM matches ORDER BY minutes DESC LIMIT 1
self correction:
SELECT winner_name, loser_name FROM matches ORDER BY minutes DESC LIMIT 1

index is 469
SELECT avg(ranking) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name
Find the average ranking for each player and their first name.
SQL generation:
SELECT AVG (T1.ranking) ,  T2.first_name FROM rankings AS T1 JOIN players AS T2 ON T1.player_id  =  T2.player_id GROUP BY T2.first_name
self correction:
SELECT AVG (T1.ranking) ,  T2.first_name FROM rankings AS T1 JOIN players AS T2 ON T1.player_id  =  T2.player_id GROUP BY T2.first_name

index is 470
SELECT avg(ranking) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name
What are the first names of all players, and their average rankings?
SQL generation:
SELECT first_name ,  AVG (ranking) FROM players JOIN rankings ON players.player_id  =  rankings.player_id GROUP BY first_name
self correction:
SELECT first_name ,  AVG(ranking)  FROM players  JOIN rankings ON players.player_id  =  rankings.player_id  GROUP BY first_name

index is 471
SELECT sum(ranking_points) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name
Find the total ranking points for each player and their first name.
SQL generation:
SELECT sum(T2.ranking_points) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name
self correction:
SELECT sum(T2.ranking_points) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name

index is 472
SELECT sum(ranking_points) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name
What are the first names of all players, and their total ranking points?
SQL generation:
SELECT first_name ,  SUM(ranking_points) FROM players JOIN rankings ON players.player_id  =  rankings.player_id GROUP BY first_name
self correction:
SELECT first_name, SUM(ranking_points)  FROM players  JOIN rankings ON players.player_id = rankings.player_id  GROUP BY first_name

index is 473
SELECT count(*) ,  country_code FROM players GROUP BY country_code
find the number of players for each country.
SQL generation:
SELECT COUNT(player_id) ,  country_code FROM players GROUP BY country_code
self correction:
SELECT COUNT(player_id) ,  country_code FROM players GROUP BY country_code

index is 474
SELECT count(*) ,  country_code FROM players GROUP BY country_code
How many players are from each country?
SQL generation:
SELECT count(player_id) ,  country_code FROM players GROUP BY country_code
self correction:
SELECT count(player_id) ,  country_code FROM players GROUP BY country_code

index is 475
SELECT country_code FROM players GROUP BY country_code ORDER BY count(*) DESC LIMIT 1
find the code of the country where has the greatest number of players.
SQL generation:
SELECT country_code FROM players GROUP BY country_code ORDER BY count(player_id) DESC LIMIT 1
self correction:
SELECT country_code, COUNT(player_id) AS player_count FROM players  GROUP BY country_code  ORDER BY player_count DESC  LIMIT 1

index is 476
SELECT country_code FROM players GROUP BY country_code ORDER BY count(*) DESC LIMIT 1
What is the code of the country with the most players?
SQL generation:
SELECT country_code FROM players GROUP BY country_code ORDER BY count(*) DESC LIMIT 1
self correction:
SELECT country_code FROM players GROUP BY country_code ORDER BY count(*) DESC LIMIT 1

index is 477
SELECT country_code FROM players GROUP BY country_code HAVING count(*)  >  50
Find the codes of countries that have more than 50 players.
SQL generation:
SELECT country_code FROM players GROUP BY country_code HAVING count(*)  >  50
self correction:
SELECT

index is 478
SELECT country_code FROM players GROUP BY country_code HAVING count(*)  >  50
What are the codes of countries with more than 50 players?
SQL generation:
SELECT country_code FROM players GROUP BY country_code HAVING count(*)  >  50
self correction:
SELECT country_code FROM players GROUP BY country_code HAVING count(player_id) > 50

index is 479
SELECT sum(tours) ,  ranking_date FROM rankings GROUP BY ranking_date
Find the total number of tours for each ranking date.
SQL generation:
SELECT sum(tours) ,  ranking_date FROM rankings GROUP BY ranking_date
self correction:
SELECT sum(tours) ,  ranking_date FROM rankings GROUP BY ranking_date

index is 480
SELECT sum(tours) ,  ranking_date FROM rankings GROUP BY ranking_date
How many total tours were there for each ranking date?
SQL generation:
SELECT SUM(tours) ,  ranking_date FROM rankings GROUP BY ranking_date
self correction:
SELECT ranking_date, SUM(tours) FROM rankings GROUP BY ranking_date

index is 481
SELECT count(*) ,  YEAR FROM matches GROUP BY YEAR
Find the number of matches happened in each year.
SQL generation:
SELECT COUNT(*) ,  year FROM matches GROUP BY year
self correction:
SELECT COUNT(*) ,  year FROM matches GROUP BY year

index is 482
SELECT count(*) ,  YEAR FROM matches GROUP BY YEAR
How many matches were played in each year?
SQL generation:
SELECT COUNT(match_num) ,  year FROM matches GROUP BY year
self correction:
SELECT COUNT(match_num) ,  year FROM matches GROUP BY year

index is 483
SELECT DISTINCT winner_name ,  winner_rank FROM matches ORDER BY winner_age LIMIT 3
Find the name and rank of the 3 youngest winners across all matches.
SQL generation:
SELECT winner_name ,  winner_rank FROM matches ORDER BY winner_age ASC LIMIT 3
self correction:
SELECT first_name, last_name, ranking FROM players JOIN matches ON players.player_id = matches.winner_id JOIN rankings ON players.player_id = rankings.player_id ORDER BY (julianday('now') - julianday(birth_date)) ASC, ranking_date DESC LIMIT 3

index is 484
SELECT DISTINCT winner_name ,  winner_rank FROM matches ORDER BY winner_age LIMIT 3
What are the names and ranks of the three youngest winners across all matches?
SQL generation:
SELECT winner_name ,  winner_rank FROM matches ORDER BY winner_age ASC LIMIT 3
self correction:
SELECT players.first_name, players.last_name, rankings.ranking  FROM matches  JOIN players ON matches.winner_id = players.player_id  JOIN rankings ON players.player_id = rankings.player_id  ORDER BY matches.winner_age ASC  LIMIT 3

index is 485
SELECT count(DISTINCT winner_name) FROM matches WHERE tourney_name  =  'WTA Championships' AND winner_hand  =  'L'
How many different winners both participated in the WTA Championships and were left handed?
SQL generation:
SELECT COUNT(DISTINCT winner_id) FROM matches WHERE tourney_name = 'WTA Championships' AND winner_hand = 'L'
self correction:
SELECT COUNT(DISTINCT m.winner_id)  FROM matches AS m  INNER JOIN players AS p ON m.winner_id = p.player_id  WHERE m.tourney_name = 'WTA Championships' AND p.hand = 'L'

index is 486
SELECT count(DISTINCT winner_name) FROM matches WHERE tourney_name  =  'WTA Championships' AND winner_hand  =  'L'
Find the number of left handed winners who participated in the WTA Championships.
SQL generation:
SELECT COUNT(DISTINCT winner_id) FROM matches JOIN players ON matches.winner_id = players.player_id WHERE winner_hand  = 'L' AND tourney_name  = 'WTA Championships' AND players.hand = 'L'
self correction:
SELECT COUNT(DISTINCT matches.winner_id)  FROM matches  JOIN players ON matches.winner_id = players.player_id  WHERE players.hand = 'L' AND matches.tourney_name = 'WTA Championships'

index is 487
SELECT T1.first_name ,  T1.country_code ,  T1.birth_date FROM players AS T1 JOIN matches AS T2 ON T1.player_id  =  T2.winner_id ORDER BY T2.winner_rank_points DESC LIMIT 1
Find the first name, country code and birth date of the winner who has the highest rank points in all matches.
SQL generation:
SELECT T1.first_name ,  T1.country_code ,  T1.birth_date FROM players AS T1 JOIN matches AS T2 ON T1.player_id  =  T2.winner_id WHERE T2.winner_rank_points  =  (SELECT max(winner_rank_points) FROM matches)
self correction:
SELECT T1.first_name, T1.country_code, T1.birth_date  FROM players AS T1  JOIN matches AS T2 ON T1.player_id = T2.winner_id  WHERE T2.winner_rank_points = (SELECT MAX(winner_rank_points) FROM matches)

index is 488
SELECT T1.first_name ,  T1.country_code ,  T1.birth_date FROM players AS T1 JOIN matches AS T2 ON T1.player_id  =  T2.winner_id ORDER BY T2.winner_rank_points DESC LIMIT 1
What is the first name, country code, and birth date of the player with the most winner rank points across all matches?
SQL generation:
SELECT T1.first_name ,  T1.country_code ,  T1.birth_date FROM players AS T1 JOIN matches AS T2 ON T1.player_id  =  T2.winner_id WHERE T2.winner_rank_points  =  (SELECT max(winner_rank_points) FROM matches)
self correction:
SELECT T1.first_name ,  T1.country_code ,  T1.birth_date FROM players AS T1 JOIN matches AS T2 ON T1.player_id  =  T2.winner_id WHERE T2.winner_rank_points  =  (SELECT max(winner_rank_points) FROM matches)

index is 489
SELECT count(*) ,  hand FROM players GROUP BY hand
Find the number of players for each hand type.
SQL generation:
SELECT count(player_id) ,  hand FROM players GROUP BY hand
self correction:
SELECT count(player_id) ,  hand FROM players GROUP BY hand

index is 490
SELECT count(*) ,  hand FROM players GROUP BY hand
How many players are there for each hand type?
SQL generation:
SELECT count(player_id) ,  hand FROM players GROUP BY hand
self correction:
SELECT count(player_id) ,  hand FROM players GROUP BY hand

index is 491
SELECT count(*) FROM ship WHERE disposition_of_ship  =  'Captured'
How many ships ended up being 'Captured'?
SQL generation:
SELECT count(id) FROM ship WHERE disposition_of_ship  =  'Captured'
self correction:
SELECT count(id) FROM ship WHERE disposition_of_ship  =  'Captured'

index is 492
SELECT name ,  tonnage FROM ship ORDER BY name DESC
List the name and tonnage ordered by in descending alphaetical order for the names.
SQL generation:
SELECT name, tonnage FROM ship ORDER BY name DESC
self correction:
SELECT name, tonnage FROM ship ORDER BY name DESC

index is 493
SELECT name ,  date FROM battle
List the name, date and result of each battle.
SQL generation:
SELECT name ,  date ,  result FROM battle
self correction:
SELECT name, date, result FROM battle

index is 494
SELECT max(killed) ,  min(killed) FROM death
What is maximum and minimum death toll caused each time?
SQL generation:
SELECT max(killed) ,  min(killed) ,  caused_by_ship_id FROM death GROUP BY caused_by_ship_id
self correction:
SELECT max(killed) ,  min(killed) ,  caused_by_ship_id FROM death GROUP BY caused_by_ship_id

index is 495
SELECT avg(injured) FROM death
What is the average number of injuries caused each time?
SQL generation:
SELECT AVG(injured) FROM death
self correction:
SELECT AVG(injured) FROM death

index is 496
SELECT T1.killed ,  T1.injured FROM death AS T1 JOIN ship AS t2 ON T1.caused_by_ship_id  =  T2.id WHERE T2.tonnage  =  't'
What are the death and injury situations caused by the ship with tonnage 't'?
SQL generation:
SELECT T2.killed ,  T2.injured FROM ship AS T1 JOIN death AS T2 ON T1.id  =  T2.caused_by_ship_id WHERE tonnage  =  't'
self correction:
SELECT T2.killed ,  T2.injured FROM ship AS T1 JOIN death AS T2 ON T1.id  =  T2.caused_by_ship_id WHERE tonnage  =  't'

index is 497
SELECT name ,  RESULT FROM battle WHERE bulgarian_commander != 'Boril'
What are the name and results of the battles when the bulgarian commander is not 'Boril'
SQL generation:
SELECT name, result FROM battle WHERE bulgarian_commander <> 'Boril'
self correction:
SELECT name, result FROM battle WHERE bulgarian_commander <> 'Boril'

index is 498
SELECT DISTINCT T1.id ,  T1.name FROM battle AS T1 JOIN ship AS T2 ON T1.id  =  T2.lost_in_battle WHERE T2.ship_type  =  'Brig'
What are the different ids and names of the battles that lost any 'Brig' type shipes?
SQL generation:
SELECT DISTINCT T1.id, T1.name FROM battle AS T1 JOIN ship AS T2 ON T1.id  =  T2.lost_in_battle WHERE T2.ship_type = 'Brig'
self correction:
SELECT DISTINCT T1.id, T1.name FROM battle AS T1 JOIN ship AS T2 ON T1.id  =  T2.lost_in_battle WHERE T2.ship_type = 'Brig'

index is 499
SELECT T1.id ,  T1.name FROM battle AS T1 JOIN ship AS T2 ON T1.id  =  T2.lost_in_battle JOIN death AS T3 ON T2.id  =  T3.caused_by_ship_id GROUP BY T1.id HAVING sum(T3.killed)  >  10
What are the ids and names of the battles that led to more than 10 people killed in total.
SQL generation:
SELECT T1.id ,  T1.name FROM battle AS T1 JOIN ship AS T2 ON T1.id  =  T2.lost_in_battle JOIN death AS T3 ON T2.id  =  T3.caused_by_ship_id GROUP BY T1.id ,  T1.name HAVING sum(T3.killed)  >  10
self correction:
SELECT T1.id, T1.name  FROM battle AS T1  JOIN ship AS T2 ON T1.id = T2.lost_in_battle  JOIN death AS T3 ON T2.id = T3.caused_by_ship_id  GROUP BY T1.id  HAVING sum(T3.killed) > 10

index is 500
SELECT T2.id ,  T2.name FROM death AS T1 JOIN ship AS t2 ON T1.caused_by_ship_id  =  T2.id GROUP BY T2.id ORDER BY count(*) DESC LIMIT 1
What is the ship id and name that caused most total injuries?
SQL generation:
SELECT T1.id ,  T1.name FROM ship AS T1 JOIN death AS T2 ON T1.id  =  T2.caused_by_ship_id GROUP BY T1.id , T1.name ORDER BY sum(T2.injured) DESC LIMIT 1
self correction:
SELECT T1.id ,  T1.name  FROM ship AS T1  JOIN death AS T2  ON T1.id  =  T2.caused_by_ship_id  GROUP BY T1.id ORDER BY sum(T2.injured) DESC  LIMIT 1

index is 501
SELECT name FROM battle WHERE bulgarian_commander  =  'Kaloyan' AND latin_commander  =  'Baldwin I'
What are the distinct battle names which are between bulgarian commander 'Kaloyan' and latin commander 'Baldwin I'?
SQL generation:
SELECT DISTINCT name FROM battle WHERE bulgarian_commander  =  'Kaloyan' AND latin_commander  =  'Baldwin I'
self correction:
SELECT DISTINCT name FROM battle WHERE bulgarian_commander  =  'Kaloyan' AND latin_commander  =  'Baldwin I'

index is 502
SELECT count(DISTINCT RESULT) FROM battle
How many different results are there for the battles?
SQL generation:
SELECT COUNT(DISTINCT result) FROM battle
self correction:
SELECT COUNT(DISTINCT result) FROM battle

index is 503
SELECT count(*) FROM battle WHERE id NOT IN ( SELECT lost_in_battle FROM ship WHERE tonnage  =  '225' );
How many battles did not lose any ship with tonnage '225'?
SQL generation:
SELECT COUNT (DISTINCT T1.id) FROM battle AS T1 JOIN ship AS T2 ON T1.id = T2.lost_in_battle WHERE T2.tonnage  =  '225' AND T2.lost_in_battle IS NULL
self correction:
SELECT COUNT (DISTINCT T1.id) FROM battle AS T1 LEFT JOIN ship AS T2 ON T1.id = T2.lost_in_battle WHERE T2.tonnage  !=  '225' OR T2.tonnage IS NULL

index is 504
SELECT T1.name ,  T1.date FROM battle AS T1 JOIN ship AS T2 ON T1.id  =  T2.lost_in_battle WHERE T2.name  =  'Lettice' INTERSECT SELECT T1.name ,  T1.date FROM battle AS T1 JOIN ship AS T2 ON T1.id  =  T2.lost_in_battle WHERE T2.name  =  'HMS Atalanta'
List the name and date the battle that has lost the ship named 'Lettice' and the ship named 'HMS Atalanta'
SQL generation:
SELECT T1.name ,  T1.date FROM battle AS T1 JOIN ship AS T2 ON T1.id  =  T2.lost_in_battle WHERE T2.name IN ('HMS Atalanta' , 'Lettice')
self correction:
SELECT T1.name ,  T1.date FROM battle AS T1 JOIN ship AS T2 ON T1.id  =  T2.lost_in_battle WHERE T2.name IN ('HMS Atalanta' , 'Lettice')

index is 505
SELECT name ,  RESULT ,  bulgarian_commander FROM battle EXCEPT SELECT T1.name ,  T1.result ,  T1.bulgarian_commander FROM battle AS T1 JOIN ship AS T2 ON T1.id  =  T2.lost_in_battle WHERE T2.location  =  'English Channel'
Show names, results and bulgarian commanders of the battles with no ships lost in the 'English Channel'.
SQL generation:
SELECT T2.name ,  T2.result ,  T2.bulgarian_commander FROM ship AS T1 RIGHT JOIN battle AS T2 ON T1.lost_in_battle  =  T2.id WHERE T1.location  =  'English Channel' AND T1.id IS NULL
self correction:
SELECT battle.name, battle.result, battle.bulgarian_commander  FROM battle  LEFT JOIN ship ON battle.id = ship.lost_in_battle  WHERE ship.lost_in_battle IS NULL AND ship.location = 'English Channel'

index is 506
SELECT note FROM death WHERE note LIKE '%East%'
What are the notes of the death events which has substring 'East'?
SQL generation:
SELECT note FROM death WHERE note LIKE '%East%'
self correction:
SELECT note FROM death WHERE note LIKE '%East%'

index is 507
SELECT line_1 ,  line_2 FROM addresses
what are all the addresses including line 1 and line 2?
SQL generation:
SELECT line_1, line_2 FROM addresses
self correction:
SELECT line_1, line_2 FROM Addresses

index is 508
SELECT line_1 ,  line_2 FROM addresses
What is the first and second line for all addresses?
SQL generation:
SELECT line_1, line_2 FROM addresses
self correction:
SELECT line_1, line_2 FROM Addresses

index is 509
SELECT count(*) FROM Courses
How many courses in total are listed?
SQL generation:
SELECT COUNT(*) FROM courses
self correction:
SELECT COUNT(*) FROM Courses

index is 510
SELECT count(*) FROM Courses
How many courses are there?
SQL generation:
SELECT COUNT(course_id) FROM courses
self correction:
SELECT COUNT(course_id) FROM Courses

index is 511
SELECT course_description FROM Courses WHERE course_name  =  'math'
How is the math course described?
SQL generation:
SELECT course_description FROM courses WHERE course_name  =  'math'
self correction:
SELECT course_description FROM Courses WHERE course_name  =  'math'

index is 512
SELECT course_description FROM Courses WHERE course_name  =  'math'
What are the descriptions for all the math courses?
SQL generation:
SELECT course_description FROM Courses INNER JOIN Departments ON Courses.course_id = Departments.department_id WHERE Departments.department_name = 'math'
self correction:
SELECT course_description  FROM Courses  INNER JOIN Sections ON Courses.course_id = Sections.course_id  INNER JOIN Departments ON Degree_Programs.department_id = Departments.department_id  INNER JOIN Degree_Programs ON Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id INNER JOIN Student_Enrolment ON Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id  INNER JOIN Student_Enrolment_Courses ON Courses.course_id = Student_Enrolment_Courses.course_id  WHERE Departments.department_name = 'math'

index is 513
SELECT zip_postcode FROM Addresses WHERE city  =  'Port Chelsea'
What is the zip code of the address in the city Port Chelsea?
SQL generation:
SELECT zip_postcode FROM Addresses WHERE city  =  "Port Chelsea"
self correction:
SELECT zip_postcode FROM Addresses WHERE city  =  "Port Chelsea"

index is 514
SELECT zip_postcode FROM Addresses WHERE city  =  'Port Chelsea'
What is the zip code for Port Chelsea?
SQL generation:
SELECT zip_postcode FROM addresses WHERE city  =  "Port Chelsea"
self correction:
SELECT zip_postcode FROM Addresses WHERE city = "Port Chelsea"

index is 515
SELECT T2.department_name ,  T1.department_id FROM Degree_Programs AS T1 JOIN Departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T1.department_id ORDER BY count(*) DESC LIMIT 1
Which department offers the most number of degrees? List department name and id.
SQL generation:
SELECT T2.department_name ,  T2.department_id ,  count(T1.degree_program_id) FROM degree_programs AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_id ORDER BY count(T1.degree_program_id) DESC LIMIT 1
self correction:
SELECT T2.department_name ,  T2.department_id ,  count(T1.degree_program_id) FROM degree_programs AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_id ORDER BY count(T1.degree_program_id) DESC LIMIT 1

index is 516
select t2.department_name ,  t1.department_id from degree_programs as t1 join departments as t2 on t1.department_id  =  t2.department_id group by t1.department_id order by count(*) desc limit 1
What is the name and id of the department with the most number of degrees ?
SQL generation:
SELECT T1.department_name ,  T1.department_id ,  count(T2.*) FROM departments AS T1 JOIN degree_programs AS T2 ON T1.department_id  =  T2.department_id GROUP BY T1.department_id ORDER BY count(T2.*) DESC LIMIT 1
self correction:
SELECT T1.department_name ,  T1.department_id ,  count(T2.degree_program_id) FROM Departments AS T1 JOIN Degree_Programs AS T2 ON T1.department_id  =  T2.department_id GROUP BY T1.department_id, T1.department_name ORDER BY count(T2.degree_program_id) DESC LIMIT 1

index is 517
SELECT count(DISTINCT department_id) FROM Degree_Programs
How many departments offer any degree?
SQL generation:
SELECT COUNT (DISTINCT department_id) FROM Degree_Programs
self correction:
SELECT COUNT (DISTINCT department_id) FROM Degree_Programs

index is 518
SELECT count(DISTINCT department_id) FROM Degree_Programs
How many different departments offer degrees?
SQL generation:
SELECT COUNT (DISTINCT department_id) FROM degree_programs
self correction:
SELECT COUNT (DISTINCT department_id) FROM degree_programs

index is 519
SELECT count(DISTINCT degree_summary_name) FROM Degree_Programs
How many different degree names are offered?
SQL generation:
SELECT COUNT(DISTINCT degree_summary_name) FROM Degree_Programs
self correction:
SELECT COUNT(DISTINCT degree_summary_name) FROM Degree_Programs

index is 520
SELECT count(DISTINCT degree_summary_name) FROM Degree_Programs
How many different degrees are offered?
SQL generation:
SELECT count(DISTINCT degree_program_id) FROM Degree_Programs
self correction:
SELECT count(DISTINCT degree_program_id) FROM Degree_Programs

index is 521
SELECT count(*) FROM Departments AS T1 JOIN Degree_Programs AS T2 ON T1.department_id  =  T2.department_id WHERE T1.department_name  =  'engineer'
How many degrees does the engineering department offer?
SQL generation:
SELECT COUNT(degree_program_id) FROM Degree_Programs WHERE department_id IN (SELECT department_id FROM Departments WHERE department_name  =  'engineering')
self correction:
SELECT COUNT(Degree_Programs.degree_program_id)  FROM Degree_Programs  INNER JOIN Departments ON Degree_Programs.department_id = Departments.department_id WHERE Departments.department_name = 'engineering'

index is 522
SELECT count(*) FROM Departments AS T1 JOIN Degree_Programs AS T2 ON T1.department_id  =  T2.department_id WHERE T1.department_name  =  'engineer'
How many degrees does the engineering department have?
SQL generation:
SELECT count(degree_program_id) FROM degree_programs WHERE department_id  =  (SELECT department_id FROM departments WHERE department_name  =  'engineering')
self correction:
SELECT count(Degree_Programs.degree_program_id)  FROM Degree_Programs  WHERE department_id = (SELECT department_id FROM Departments WHERE department_name = 'Engineering')

index is 523
SELECT section_name ,  section_description FROM Sections
What are the names and descriptions of all the sections?
SQL generation:
SELECT section_name ,  section_description FROM sections
self correction:
SELECT section_name ,  section_description FROM Sections

index is 524
SELECT section_name ,  section_description FROM Sections
What are the names and descriptions for all the sections?
SQL generation:
SELECT section_name, section_description FROM sections
self correction:
SELECT section_name, section_description FROM Sections

index is 525
SELECT T1.course_name ,  T1.course_id FROM Courses AS T1 JOIN Sections AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_id HAVING count(*)  <=  2
What are the names and id of courses having at most 2 sections?
SQL generation:
SELECT T1.course_name ,  T1.course_id FROM courses AS T1 JOIN sections AS T2 ON T1.course_id  =  T2.course_id GROUP BY T2.course_id HAVING count(T2.section_id) <= 2
self correction:
SELECT T1.course_name ,  T1.course_id  FROM Courses AS T1  JOIN Sections AS T2 ON T1.course_id  =  T2.course_id  GROUP BY T1.course_id, T1.course_name HAVING count(T2.section_id) <= 2

index is 526
SELECT T1.course_name ,  T1.course_id FROM Courses AS T1 JOIN Sections AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_id HAVING count(*)  <=  2
What are the names and ids of every course with less than 2 sections?
SQL generation:
SELECT T1.course_name, T1.course_id, COUNT(T2.section_id) FROM Courses AS T1 JOIN Sections AS T2 ON T1.course_id = T2.course_id GROUP BY T1.course_id HAVING COUNT(T2.section_id) < 2
self correction:
SELECT T1.course_name, T1.course_id, COUNT(T2.section_id)  FROM Courses AS T1  JOIN Sections AS T2 ON T1.course_id = T2.course_id  GROUP BY T1.course_id, T1.course_name  HAVING COUNT(T2.section_id) < 2

index is 527
SELECT section_name FROM Sections ORDER BY section_name DESC
List the section_name in reversed lexicographical order.
SQL generation:
SELECT section_name FROM sections ORDER BY section_name DESC
self correction:
SELECT section_name FROM Sections ORDER BY section_name DESC

index is 528
SELECT section_name FROM Sections ORDER BY section_name DESC
What are the names of the sections in reverse alphabetical order?
SQL generation:
SELECT section_name FROM sections ORDER BY section_name DESC
self correction:
SELECT section_name FROM Sections ORDER BY section_name DESC

index is 529
SELECT T1.semester_name ,  T1.semester_id FROM Semesters AS T1 JOIN Student_Enrolment AS T2 ON T1.semester_id  =  T2.semester_id GROUP BY T1.semester_id ORDER BY count(*) DESC LIMIT 1
What is the semester which most student registered in? Show both the name and the id.
SQL generation:
SELECT T1.semester_name ,  T1.semester_id FROM semesters AS T1 JOIN student_enrolment AS T2 ON T1.semester_id  =  T2.semester_id GROUP BY T2.semester_id ORDER BY count(T2.student_id) DESC LIMIT 1
self correction:
SELECT T1.semester_name ,  T1.semester_id FROM semesters AS T1 JOIN student_enrolment AS T2 ON T1.semester_id  =  T2.semester_id GROUP BY T2.semester_id ORDER BY count(T2.student_id) DESC LIMIT 1

index is 530
SELECT T1.semester_name ,  T1.semester_id FROM Semesters AS T1 JOIN Student_Enrolment AS T2 ON T1.semester_id  =  T2.semester_id GROUP BY T1.semester_id ORDER BY count(*) DESC LIMIT 1
For each semester, what is the name and id of the one with the most students registered?
SQL generation:
SELECT T1.semester_id ,  T1.semester_name ,  COUNT (T2.student_id) FROM semesters AS T1 JOIN student_enrolment AS T2 ON T1.semester_id  =  T2.semester_id GROUP BY T1.semester_id ORDER BY COUNT(T2.student_id) DESC
self correction:
SELECT T1.semester_id ,  T1.semester_name ,  COUNT (DISTINCT T2.student_id) FROM semesters AS T1 JOIN student_enrolment AS T2 ON T1.semester_id  =  T2.semester_id GROUP BY T1.semester_id, T1.semester_name ORDER BY COUNT(DISTINCT T2.student_id) DESC LIMIT 1

index is 531
SELECT department_description FROM Departments WHERE department_name LIKE '%computer%'
What is the description of the department whose name has the substring the computer?
SQL generation:
SELECT department_description FROM departments WHERE department_name LIKE '%the computer%'
self correction:
SELECT department_description FROM Departments WHERE department_name LIKE '%the computer%'

index is 532
SELECT department_description FROM Departments WHERE department_name LIKE '%computer%'
What is the department description for the one whose name has the word computer?
SQL generation:
SELECT department_description FROM departments WHERE department_name LIKE '%computer%'
self correction:
SELECT department_description FROM Departments WHERE department_name LIKE '%computer%'

index is 533
SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  2
Who are enrolled in 2 degree programs in one semester? List the first name, middle name and last name and the id.
SQL generation:
SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM students AS T1 JOIN student_enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ,  T2.semester_id HAVING count(T2.degree_program_id)  =  2
self correction:
SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ,  T2.semester_id HAVING count(DISTINCT T2.degree_program_id)  =  2

index is 534
SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  2
What are the first, middle, and last names, along with the ids, of all students who enrolled in 2 degree programs in one semester?
SQL generation:
SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM students AS T1 JOIN student_enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T2.student_id ,  T2.semester_id HAVING count(T2.degree_program_id) = 2
self correction:
SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id  FROM Students AS T1  JOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id  GROUP BY T1.student_id, T2.semester_id  HAVING COUNT(DISTINCT T2.degree_program_id) = 2

index is 535
SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  'Bachelor'
Who is enrolled in a Bachelor degree program? List the first name, middle name, last name.
SQL generation:
SELECT T1.first_name, T1.middle_name, T1.last_name FROM students AS T1 JOIN student_enrolment AS T2 ON T1.student_id = T2.student_id JOIN degree_programs AS T3 ON T2.degree_program_id = T3.degree_program_id WHERE T3.degree_summary_name = 'Bachelor'
self correction:
SELECT T1.first_name, T1.middle_name, T1.last_name FROM students AS T1 JOIN student_enrolment AS T2 ON T1.student_id = T2.student_id JOIN degree_programs AS T3 ON T2.degree_program_id = T3.degree_program_id WHERE T3.degree_summary_name = 'Bachelor'

index is 536
SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  'Bachelor'
What are the first, middle, and last names for everybody enrolled in a Bachelors program?
SQL generation:
SELECT T1.first_name ,  T1.middle_name ,  T1.last_name FROM students AS T1 JOIN student_enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN degree_programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  'Bachelors'
self correction:
SELECT T1.first_name ,  T1.middle_name ,  T1.last_name FROM students AS T1 JOIN student_enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN degree_programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  'Bachelors'

index is 537
SELECT T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_summary_name ORDER BY count(*) DESC LIMIT 1
Find the kind of program which most number of students are enrolled in?
SQL generation:
SELECT T2.degree_summary_name FROM student_enrolment AS T1 JOIN degree_programs AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T2.degree_summary_name ORDER BY count(T1.degree_program_id) DESC LIMIT 1
self correction:
SELECT T2.degree_summary_name FROM student_enrolment AS T1 JOIN degree_programs AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T2.degree_summary_name ORDER BY count(T1.degree_program_id) DESC LIMIT 1

index is 538
SELECT T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_summary_name ORDER BY count(*) DESC LIMIT 1
What is the degree summary name that has the most number of students enrolled?
SQL generation:
SELECT degree_summary_name FROM degree_programs JOIN student_enrolment ON degree_programs.degree_program_id = student_enrolment.degree_program_id GROUP BY degree_summary_name ORDER BY count(*) DESC LIMIT 1
self correction:
SELECT degree_summary_name  FROM Degree_Programs  JOIN Student_Enrolment ON Degree_Programs.degree_program_id = Student_Enrolment.degree_program_id  GROUP BY degree_summary_name  ORDER BY count(*) DESC  LIMIT 1

index is 539
SELECT T1.degree_program_id ,  T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_program_id ORDER BY count(*) DESC LIMIT 1
Find the program which most number of students are enrolled in. List both the id and the summary.
SQL generation:
SELECT T2.degree_program_id, T2.degree_summary_name FROM student_enrolment AS T1 JOIN degree_programs AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_program_id ORDER BY COUNT(*) DESC LIMIT 1
self correction:
SELECT T2.degree_program_id, T2.degree_summary_name FROM student_enrolment AS T1 JOIN degree_programs AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_program_id ORDER BY COUNT(*) DESC LIMIT 1

index is 540
SELECT T1.degree_program_id ,  T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_program_id ORDER BY count(*) DESC LIMIT 1
What is the program id and the summary of the degree that has the most students enrolled?
SQL generation:
SELECT degree_program_id, degree_summary_name FROM degree_programs WHERE degree_program_id IN (SELECT degree_program_id FROM student_enrolment GROUP BY degree_program_id ORDER BY COUNT(student_id) DESC LIMIT 1)
self correction:
SELECT degree_program_id, degree_summary_name  FROM Degree_Programs  WHERE degree_program_id IN (     SELECT degree_program_id      FROM Student_Enrolment      GROUP BY degree_program_id      ORDER BY COUNT(*) DESC      LIMIT 1 )

index is 541
SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1
Which student has enrolled for the most times in any program? List the id, first name, middle name, last name, the number of enrollments and student id.
SQL generation:
SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(T2.student_enrolment_id) FROM students AS T1 JOIN student_enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T2.student_id ORDER BY count(T2.student_enrolment_id) DESC LIMIT 1
self correction:
SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, COUNT(T2.student_enrolment_id) AS 'Number of Enrollments' FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id, T1.first_name, T1.middle_name, T1.last_name ORDER BY COUNT(T2.student_enrolment_id) DESC LIMIT 1

index is 542
SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1
What is the first, middle, and last name, along with the id and number of enrollments, for the student who enrolled the most in any program?
SQL generation:
SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id, count(T2.student_id) FROM students AS T1 JOIN student_enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T2.student_id ORDER BY count(T2.student_id) DESC LIMIT 1
self correction:
SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id, count(T2.student_id) FROM students AS T1 JOIN student_enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T2.student_id ORDER BY count(T2.student_id) DESC LIMIT 1

index is 543
SELECT semester_name FROM Semesters WHERE semester_id NOT IN( SELECT semester_id FROM Student_Enrolment )
Which semesters do not have any student enrolled? List the semester name.
SQL generation:
SELECT semester_name FROM semesters WHERE semester_id NOT IN (SELECT semester_id FROM student_enrolment)
self correction:
SELECT semester_name FROM Semesters WHERE semester_id NOT IN (SELECT semester_id FROM Student_Enrolment)

index is 544
SELECT semester_name FROM Semesters WHERE semester_id NOT IN( SELECT semester_id FROM Student_Enrolment )
What is the name of the semester with no students enrolled?
SQL generation:
SELECT semester_name FROM semesters WHERE semester_id NOT IN (SELECT semester_id FROM student_enrolment)
self correction:
SELECT semester_name FROM Semesters WHERE semester_id NOT IN (SELECT semester_id FROM Student_Enrolment)

index is 545
SELECT DISTINCT T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id
What are all the course names of the courses which ever have students enrolled in?
SQL generation:
SELECT DISTINCT course_name FROM courses WHERE course_id IN (SELECT course_id FROM student_enrolment_courses)
self correction:
SELECT DISTINCT course_name FROM Courses WHERE course_id IN (SELECT course_id FROM Student_Enrolment_Courses)

index is 546
SELECT DISTINCT T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id
What are the names of all courses that have some students enrolled?
SQL generation:
SELECT DISTINCT course_name FROM Courses WHERE course_id IN (SELECT course_id FROM Student_Enrolment_Courses)
self correction:
SELECT DISTINCT course_name  FROM Courses  WHERE course_id IN (SELECT course_id FROM Student_Enrolment_Courses)

index is 547
SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT 1
What's the name of the course with most number of enrollments?
SQL generation:
SELECT T2.course_name FROM student_enrolment_courses AS T1 JOIN courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_id ORDER BY count(T1.student_course_id) DESC LIMIT 1
self correction:
SELECT T2.course_name FROM Student_Enrolment_Courses AS T1 JOIN Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_id ORDER BY count(T1.student_course_id) DESC LIMIT 1

index is 548
SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT 1
What is the name of the course with the most students enrolled?
SQL generation:
SELECT T1.course_name FROM courses AS T1 JOIN student_enrolment_courses AS T2 ON T1.course_id = T2.course_id GROUP BY T2.course_id ORDER BY count(T2.student_enrolment_id) DESC LIMIT 1
self correction:
SELECT T1.course_name  FROM Courses AS T1  JOIN Student_Enrolment_Courses AS T2  ON T1.course_id = T2.course_id  GROUP BY T1.course_id  ORDER BY COUNT(T2.student_course_id) DESC  LIMIT 1

index is 549
SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  'NorthCarolina' EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id
Find the last name of the students who currently live in the state of North Carolina but have not registered in any degree program.
SQL generation:
SELECT T1.last_name FROM students AS T1 JOIN addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  'North Carolina' AND NOT EXISTS (SELECT * FROM student_enrolment AS T3 WHERE T1.student_id  =  T3.student_id)
self correction:
SELECT T1.last_name  FROM Students AS T1  JOIN Addresses AS T2  ON T1.current_address_id = T2.address_id  WHERE T2.state_province_county = 'North Carolina'  AND NOT EXISTS (     SELECT *      FROM Student_Enrolment AS T3      WHERE T1.student_id = T3.student_id )

index is 550
SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  'NorthCarolina' EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id
What are the last name of the students who live in North Carolina but have not registered in any degree programs?
SQL generation:
SELECT T1.last_name FROM students AS T1 JOIN addresses AS T2 ON T1.current_address_id = T2.address_id WHERE T2.state_province_county  =  'North Carolina' AND NOT EXISTS ( SELECT * FROM student_enrolment AS T3 WHERE T1.student_id  =  T3.student_id )
self correction:
SELECT T1.last_name FROM students AS T1 JOIN addresses AS T2 ON T1.current_address_id = T2.address_id WHERE T2.state_province_county  =  'North Carolina' AND NOT EXISTS ( SELECT * FROM student_enrolment AS T3 WHERE T1.student_id  =  T3.student_id )

index is 551
SELECT T2.transcript_date ,  T1.transcript_id FROM Transcript_Contents AS T1 JOIN Transcripts AS T2 ON T1.transcript_id  =  T2.transcript_id GROUP BY T1.transcript_id HAVING count(*)  >=  2
Show the date and id of the transcript with at least 2 course results.
SQL generation:
SELECT T1.transcript_date ,  T1.transcript_id FROM transcripts AS T1 JOIN transcript_contents AS T2 ON T1.transcript_id  =  T2.transcript_id GROUP BY T1.transcript_id HAVING COUNT(T2.student_course_id) >= 2
self correction:
SELECT T1.transcript_date, T1.transcript_id  FROM Transcripts AS T1  JOIN Transcript_Contents AS T2  ON T1.transcript_id = T2.transcript_id  GROUP BY T1.transcript_id, T1.transcript_date  HAVING COUNT(T2.student_course_id) >= 2

index is 552
SELECT T2.transcript_date ,  T1.transcript_id FROM Transcript_Contents AS T1 JOIN Transcripts AS T2 ON T1.transcript_id  =  T2.transcript_id GROUP BY T1.transcript_id HAVING count(*)  >=  2
What is the date and id of the transcript with at least 2 courses listed?
SQL generation:
SELECT T1.transcript_date ,  T1.transcript_id FROM transcripts AS T1 JOIN transcript_contents AS T2 ON T1.transcript_id  =  T2.transcript_id GROUP BY T1.transcript_id HAVING count(*) >= 2
self correction:
SELECT T1.transcript_date ,  T1.transcript_id FROM Transcripts AS T1 JOIN Transcript_Contents AS T2 ON T1.transcript_id  =  T2.transcript_id GROUP BY T1.transcript_id HAVING count(*) >= 2

index is 553
SELECT cell_mobile_number FROM Students WHERE first_name  =  'Timmothy' AND last_name  =  'Ward'
What is the phone number of the man with the first name Timmothy and the last name Ward?
SQL generation:
SELECT cell_mobile_number FROM students WHERE first_name  =  'Timmothy' AND last_name  =  'Ward'
self correction:
SELECT cell_mobile_number FROM Students WHERE first_name  =  'Timmothy' AND last_name  =  'Ward'

index is 554
select cell_mobile_number from students where first_name  =  'timmothy' and last_name  =  'ward'
What is the mobile phone number of the student named Timmothy Ward ?
SQL generation:
SELECT cell_mobile_number FROM students WHERE first_name = 'Timmothy' AND last_name = 'Ward'
self correction:
SELECT cell_mobile_number FROM Students WHERE first_name = 'Timmothy' AND last_name = 'Ward'

index is 555
SELECT first_name ,  middle_name ,  last_name FROM Students ORDER BY date_first_registered ASC LIMIT 1
Who is the first student to register? List the first name, middle name and last name.
SQL generation:
SELECT first_name, middle_name, last_name FROM students ORDER BY date_first_registered ASC LIMIT 1
self correction:
SELECT first_name, middle_name, last_name FROM Students ORDER BY date_first_registered ASC LIMIT 1

index is 556
SELECT first_name ,  middle_name ,  last_name FROM Students ORDER BY date_first_registered ASC LIMIT 1
What is the first, middle, and last name of the first student to register?
SQL generation:
SELECT first_name ,  middle_name ,  last_name FROM students ORDER BY date_first_registered ASC LIMIT 1
self correction:
SELECT first_name ,  middle_name ,  last_name FROM Students ORDER BY date_first_registered ASC LIMIT 1

index is 557
SELECT first_name ,  middle_name ,  last_name FROM Students ORDER BY date_left ASC LIMIT 1
Who is the earliest graduate of the school? List the first name, middle name and last name.
SQL generation:
SELECT first_name , middle_name , last_name FROM students ORDER BY date_left ASC LIMIT 1
self correction:
SELECT first_name , middle_name , last_name FROM Students ORDER BY date_left ASC LIMIT 1

index is 558
SELECT first_name ,  middle_name ,  last_name FROM Students ORDER BY date_left ASC LIMIT 1
What is the first, middle, and last name of the earliest school graduate?
SQL generation:
SELECT first_name, middle_name, last_name FROM students ORDER BY date_left ASC LIMIT 1
self correction:
SELECT Students.first_name, Students.middle_name, Students.last_name FROM Students WHERE date_left IS NOT NULL ORDER BY date_left ASC LIMIT 1

index is 559
SELECT first_name FROM Students WHERE current_address_id != permanent_address_id
Whose permanent address is different from his or her current address? List his or her first name.
SQL generation:
SELECT first_name FROM students WHERE permanent_address_id != current_address_id
self correction:
SELECT first_name FROM Students WHERE permanent_address_id != current_address_id

index is 560
SELECT first_name FROM Students WHERE current_address_id != permanent_address_id
What is the first name of the student whose permanent address is different from his or her current one?
SQL generation:
SELECT first_name FROM students WHERE permanent_address_id != current_address_id
self correction:
SELECT first_name FROM Students WHERE permanent_address_id != current_address_id

index is 561
SELECT T1.address_id ,  T1.line_1 ,  T1.line_2 FROM Addresses AS T1 JOIN Students AS T2 ON T1.address_id  =  T2.current_address_id GROUP BY T1.address_id ORDER BY count(*) DESC LIMIT 1
Which address holds the most number of students currently? List the address id and all lines.
SQL generation:
SELECT T2.address_id ,  T2.line_1 ,  T2.line_2 ,  T2.line_3 ,  count(T1.current_address_id) FROM students AS T1 JOIN addresses AS T2 ON T1.current_address_id  =  T2.address_id GROUP BY T2.address_id ,  T2.line_1 ,  T2.line_2 ,  T2.line_3 ORDER BY count(T1.current_address_id) DESC LIMIT 1
self correction:
SELECT T2.address_id, T2.line_1, T2.line_2, T2.line_3, count(T1.current_address_id) AS students_count  FROM Students AS T1  JOIN Addresses AS T2 ON T1.current_address_id = T2.address_id  GROUP BY T2.address_id  ORDER BY students_count DESC  LIMIT 1

index is 562
SELECT T1.address_id ,  T1.line_1 ,  T1.line_2 FROM Addresses AS T1 JOIN Students AS T2 ON T1.address_id  =  T2.current_address_id GROUP BY T1.address_id ORDER BY count(*) DESC LIMIT 1
What is the id, line 1, and line 2 of the address with the most students?
SQL generation:
SELECT address_id ,  line_1 ,  line_2 FROM addresses WHERE address_id  =  (SELECT current_address_id FROM students GROUP BY current_address_id ORDER BY count(student_id) DESC LIMIT 1)
self correction:
SELECT address_id, line_1, line_2  FROM Addresses  WHERE address_id IN (   SELECT current_address_id    FROM Students    GROUP BY current_address_id    ORDER BY COUNT(student_id) DESC    LIMIT 1 )

index is 563
SELECT avg(transcript_date) FROM Transcripts
On average, when were the transcripts printed?
SQL generation:
SELECT AVG (transcript_date) FROM transcripts
self correction:
SELECT AVG (transcript_date) FROM transcripts

index is 564
SELECT avg(transcript_date) FROM Transcripts
What is the average transcript date?
SQL generation:
SELECT AVG(transcript_date) FROM transcripts
self correction:
SELECT AVG(transcript_date) FROM Transcripts

index is 565
SELECT transcript_date ,  other_details FROM Transcripts ORDER BY transcript_date ASC LIMIT 1
When is the first transcript released? List the date and details.
SQL generation:
SELECT transcript_date, other_details FROM Transcripts ORDER BY transcript_date ASC LIMIT 1
self correction:
SELECT transcript_date, other_details FROM Transcripts ORDER BY transcript_date ASC LIMIT 1
